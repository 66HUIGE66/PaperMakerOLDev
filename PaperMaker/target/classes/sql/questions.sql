/*
 Navicat Premium Data Transfer

 Source Server         : SEPG
 Source Server Type    : MySQL
 Source Server Version : 80034
 Source Host           : localhost:3306
 Source Schema         : sepgdb

 Target Server Type    : MySQL
 Target Server Version : 80034
 File Encoding         : 65001

 Date: 11/11/2025 16:58:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for questions
-- ----------------------------
DROP TABLE IF EXISTS `questions`;
CREATE TABLE `questions`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '题目ID',
  `title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '题目标题',
  `type` enum('SINGLE_CHOICE','MULTIPLE_CHOICE','FILL_BLANK','TRUE_FALSE','SHORT_ANSWER') CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '题目类型',
  `difficulty` enum('EASY','MEDIUM','HARD') CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '难度等级',
  `options` json NULL COMMENT '选择题选项（JSON格式）',
  `correct_answer` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '正确答案',
  `explanation` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '题目解析',
  `is_system` tinyint(1) NULL DEFAULT 0 COMMENT '是否为系统题目',
  `creator_id` bigint NOT NULL COMMENT '创建者ID',
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `knowledge_point_ids` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '知识点ID列表（JSON格式）',
  `subject_id` bigint NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_type`(`type` ASC) USING BTREE,
  INDEX `idx_difficulty`(`difficulty` ASC) USING BTREE,
  INDEX `idx_is_system`(`is_system` ASC) USING BTREE,
  INDEX `idx_creator`(`creator_id` ASC) USING BTREE,
  CONSTRAINT `questions_ibfk_1` FOREIGN KEY (`creator_id`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 792 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '题目表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of questions
-- ----------------------------
INSERT INTO `questions` VALUES (14, '以下哪个是Python的基本数据类型？', 'SINGLE_CHOICE', 'EASY', '[\"list\", \"dict\", \"tuple\", \"以上都是\"]', 'D', 'Python的基本数据类型包括list、dict、tuple等', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[9, 10]', 7);
INSERT INTO `questions` VALUES (15, '以下哪些是数据库操作？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"SELECT\", \"INSERT\", \"UPDATE\", \"DELETE\"]', 'A,B,C,D', '数据库的基本操作包括增删改查', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[13, 14]', 9);
INSERT INTO `questions` VALUES (16, 'HTML是标记语言吗？', 'TRUE_FALSE', 'EASY', NULL, 'TRUE', 'HTML是超文本标记语言', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[15, 16, 17]', 10);
INSERT INTO `questions` VALUES (17, '请简述什么是算法？', 'SHORT_ANSWER', 'HARD', NULL, '算法是解决问题的步骤和方法', '算法是计算机科学的核心概念', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[19, 20]', 11);
INSERT INTO `questions` VALUES (18, '以下哪个是JavaScript的数据类型？', 'SINGLE_CHOICE', 'EASY', '[\"number\", \"string\", \"boolean\", \"以上都是\"]', 'D', 'JavaScript有多种数据类型', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[24, 25]', 8);
INSERT INTO `questions` VALUES (19, '以下哪些是HTTP状态码？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"200\", \"404\", \"500\", \"999\"]', 'A,B,C', 'HTTP状态码表示请求的处理结果', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[17, 18]', 10);
INSERT INTO `questions` VALUES (20, 'CSS用于网页样式设计吗？', 'TRUE_FALSE', 'EASY', NULL, 'TRUE', 'CSS是层叠样式表，用于网页样式', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[15, 16, 17]', 10);
INSERT INTO `questions` VALUES (21, '请解释什么是面向对象编程？', 'SHORT_ANSWER', 'HARD', NULL, '面向对象编程是一种编程范式，通过对象来组织代码', '面向对象编程是重要的编程思想', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[27, 28, 29]', 12);
INSERT INTO `questions` VALUES (22, '以下哪个是Linux命令？', 'SINGLE_CHOICE', 'MEDIUM', '[\"ls\", \"dir\", \"list\", \"show\"]', 'A', 'ls是Linux中列出目录内容的命令', 1, 1, '2025-09-22 23:23:50', '2025-10-31 09:34:39', '[31, 32]', 13);
INSERT INTO `questions` VALUES (23, '以下哪个是Python的基本数据类型？', 'SINGLE_CHOICE', 'EASY', '[\"list\", \"dict\", \"tuple\", \"以上都是\"]', 'D', 'Python的基本数据类型包括list、dict、tuple等', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[8, 9]', 7);
INSERT INTO `questions` VALUES (24, '以下哪些是数据库操作？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"SELECT\", \"INSERT\", \"UPDATE\", \"DELETE\"]', 'A,B,C,D', '数据库的基本操作包括增删改查', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[11, 12, 13]', 9);
INSERT INTO `questions` VALUES (25, 'HTML是标记语言吗？', 'TRUE_FALSE', 'EASY', NULL, 'TRUE', 'HTML是超文本标记语言', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[15, 16]', 10);
INSERT INTO `questions` VALUES (26, '请简述什么是算法？', 'SHORT_ANSWER', 'HARD', NULL, '算法是解决问题的步骤和方法', '算法是计算机科学的核心概念', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[20, 21]', 11);
INSERT INTO `questions` VALUES (27, '以下哪个是JavaScript的数据类型？', 'SINGLE_CHOICE', 'EASY', '[\"number\", \"string\", \"boolean\", \"以上都是\"]', 'D', 'JavaScript有多种数据类型', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[25, 26]', 8);
INSERT INTO `questions` VALUES (28, '以下哪些是HTTP状态码？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"200\", \"404\", \"500\", \"999\"]', 'A,B,C', 'HTTP状态码表示请求的处理结果', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[15, 16, 17]', 10);
INSERT INTO `questions` VALUES (29, 'CSS用于网页样式设计吗？', 'TRUE_FALSE', 'EASY', NULL, 'TRUE', 'CSS是层叠样式表，用于网页样式', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[15, 16]', 10);
INSERT INTO `questions` VALUES (30, '请解释什么是面向对象编程？', 'SHORT_ANSWER', 'HARD', NULL, '面向对象编程是一种编程范式，通过对象来组织代码', '面向对象编程是重要的编程思想', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[27, 28, 29]', 12);
INSERT INTO `questions` VALUES (31, '以下哪个是Linux命令？', 'SINGLE_CHOICE', 'MEDIUM', '[\"ls\", \"dir\", \"list\", \"show\"]', 'A', 'ls是Linux中列出目录内容的命令', 1, 1, '2025-09-22 23:26:57', '2025-10-31 09:34:39', '[32, 33]', 13);
INSERT INTO `questions` VALUES (36, '1d', 'FILL_BLANK', 'EASY', NULL, 'd12d21', '', 1, 1, '2025-09-23 15:41:06', '2025-09-28 16:41:12', '[]', NULL);
INSERT INTO `questions` VALUES (37, 'tttt', 'TRUE_FALSE', 'MEDIUM', NULL, 'TRUE', '213', 1, 1, '2025-09-23 15:41:23', '2025-09-28 16:41:12', '[]', NULL);
INSERT INTO `questions` VALUES (53, '中国的首都是哪个城市？', 'SINGLE_CHOICE', 'EASY', '[\"上海\", \"广州\", \"北京\", \"深圳\"]', '北京', '北京是中国的政治和文化中心。', 0, 1, '2025-09-23 16:41:07', '2025-10-31 09:34:39', '[35, 36]', 14);
INSERT INTO `questions` VALUES (54, '水的化学式是什么？', 'FILL_BLANK', 'EASY', NULL, 'H₂O', '水分子由两个氢原子和一个氧原子组成。', 0, 1, '2025-09-23 16:41:07', '2025-10-31 09:34:39', '[37, 38, 39]', 3);
INSERT INTO `questions` VALUES (55, '简述光合作用的过程。', 'SHORT_ANSWER', 'MEDIUM', NULL, '光合作用是植物利用光能将二氧化碳和水转化为有机物和氧气的过程。', '这一过程发生在叶绿体中，是地球上生命存在的基础。', 0, 1, '2025-09-23 16:41:07', '2025-10-31 09:34:39', '[40, 41]', 4);
INSERT INTO `questions` VALUES (56, '以下哪些是编程语言？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"Java\", \"MySQL\", \"Python\", \"HTML\"]', 'Java,Python', 'MySQL是数据库系统，HTML是标记语言，不是编程语言。', 0, 1, '2025-09-23 16:41:07', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (57, '分析区块链技术对金融行业的影响。', 'SHORT_ANSWER', 'HARD', NULL, '区块链技术通过去中心化、不可篡改的特性，正在重塑金融行业的信任机制和交易方式...', '需要从技术特点、应用场景和行业变革多个角度进行分析。', 0, 1, '2025-09-23 16:41:07', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (58, '以下哪个是面向对象编程的特性？', 'SINGLE_CHOICE', 'EASY', '[\"封装\", \"继承\", \"多态\", \"以上都是\"]', 'D', '面向对象编程的三大特性是封装、继承和多态。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (59, 'Java中，以下哪个关键字用于继承？', 'SINGLE_CHOICE', 'EASY', '[\"extends\", \"implements\", \"class\", \"interface\"]', 'A', 'Java中使用extends关键字实现类继承。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (60, '以下哪个数据结构是先进先出(FIFO)？', 'SINGLE_CHOICE', 'MEDIUM', '[\"栈\", \"队列\", \"链表\", \"树\"]', 'B', '队列是先进先出的数据结构。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (61, '以下哪个算法的时间复杂度是O(n²)？', 'SINGLE_CHOICE', 'MEDIUM', '[\"快速排序\", \"冒泡排序\", \"归并排序\", \"堆排序\"]', 'B', '冒泡排序的时间复杂度是O(n²)。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (62, '以下哪个是数据库的ACID特性？', 'MULTIPLE_CHOICE', 'HARD', '[\"原子性\", \"一致性\", \"隔离性\", \"持久性\"]', '[\"A\", \"B\", \"C\", \"D\"]', 'ACID是数据库事务的四个特性：原子性、一致性、隔离性、持久性。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (63, '请简述什么是递归？', 'SHORT_ANSWER', 'MEDIUM', '[]', '递归是一种编程技术，函数调用自身来解决问题。', '递归是函数直接或间接调用自身的过程，通常用于解决可以分解为相同子问题的问题。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (64, 'TCP和UDP的主要区别是什么？', 'SHORT_ANSWER', 'HARD', '[]', 'TCP是面向连接的可靠传输协议，UDP是无连接的不可靠传输协议。', 'TCP提供可靠的数据传输，有连接建立和断开过程；UDP提供快速但不保证可靠性的传输。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (65, '以下哪个是HTTP状态码200的含义？', 'SINGLE_CHOICE', 'EASY', '[\"请求成功\", \"未找到\", \"服务器错误\", \"重定向\"]', 'A', 'HTTP状态码200表示请求成功。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (66, '以下哪个是设计模式？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"单例模式\", \"工厂模式\", \"观察者模式\", \"循环模式\"]', '[\"A\", \"B\", \"C\"]', '单例模式、工厂模式、观察者模式都是常见的设计模式。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (67, '请解释什么是多线程？', 'SHORT_ANSWER', 'HARD', '[]', '多线程是指程序中同时执行多个线程的技术。', '多线程允许程序同时执行多个任务，提高程序的并发性和效率。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 5);
INSERT INTO `questions` VALUES (68, '2 + 2 = ?', 'SINGLE_CHOICE', 'EASY', '[\"3\", \"4\", \"5\", \"6\"]', 'B', '2 + 2 = 4', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[47, 48, 49]', 2);
INSERT INTO `questions` VALUES (69, '以下哪个是质数？', 'SINGLE_CHOICE', 'EASY', '[\"4\", \"6\", \"7\", \"8\"]', 'C', '7是质数，只能被1和7整除。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[47, 48]', 2);
INSERT INTO `questions` VALUES (70, '以下哪个是二次方程？', 'SINGLE_CHOICE', 'MEDIUM', '[\"x + 1 = 0\", \"x² + 2x + 1 = 0\", \"x³ + 1 = 0\", \"2x + 3 = 0\"]', 'B', 'x² + 2x + 1 = 0是二次方程。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[48, 49]', 2);
INSERT INTO `questions` VALUES (71, '以下哪个是三角函数？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"sin\", \"cos\", \"tan\", \"log\"]', '[\"A\", \"B\", \"C\"]', 'sin、cos、tan都是三角函数。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[49, 50]', 2);
INSERT INTO `questions` VALUES (72, '请计算 ∫x dx', 'SHORT_ANSWER', 'HARD', '[]', 'x²/2 + C', '∫x dx = x²/2 + C，其中C是积分常数。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[47, 48, 49]', 2);
INSERT INTO `questions` VALUES (73, '以下哪个是几何图形？', 'MULTIPLE_CHOICE', 'EASY', '[\"圆\", \"三角形\", \"正方形\", \"函数\"]', '[\"A\", \"B\", \"C\"]', '圆、三角形、正方形都是几何图形。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[47, 48]', 2);
INSERT INTO `questions` VALUES (74, '以下哪个是代数表达式？', 'SINGLE_CHOICE', 'MEDIUM', '[\"2x + 3\", \"πr²\", \"sin(x)\", \"log(x)\"]', 'A', '2x + 3是代数表达式。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[48, 49]', 2);
INSERT INTO `questions` VALUES (75, '请解释什么是导数？', 'SHORT_ANSWER', 'HARD', '[]', '导数是函数在某点的瞬时变化率。', '导数表示函数在某点的切线斜率，即函数值的变化率。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[49, 50]', 2);
INSERT INTO `questions` VALUES (76, '以下哪个是力的单位？', 'SINGLE_CHOICE', 'EASY', '[\"牛顿\", \"焦耳\", \"瓦特\", \"伏特\"]', 'A', '力的单位是牛顿(N)。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[43, 44, 45]', 1);
INSERT INTO `questions` VALUES (77, '以下哪个是能量守恒定律？', 'SINGLE_CHOICE', 'MEDIUM', '[\"能量不能创造也不能消灭\", \"能量可以无限创造\", \"能量会逐渐消失\", \"能量只存在于特定形式\"]', 'A', '能量守恒定律指出能量不能创造也不能消灭，只能转换形式。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[43, 44]', 1);
INSERT INTO `questions` VALUES (78, '以下哪个是电磁波？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"光\", \"无线电波\", \"X射线\", \"声波\"]', '[\"A\", \"B\", \"C\"]', '光、无线电波、X射线都是电磁波。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[44, 45]', 1);
INSERT INTO `questions` VALUES (79, '请解释什么是惯性？', 'SHORT_ANSWER', 'MEDIUM', '[]', '惯性是物体保持静止或匀速直线运动状态的性质。', '惯性是物体抵抗运动状态改变的性质，是牛顿第一定律的基础。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[45, 46]', 1);
INSERT INTO `questions` VALUES (80, '以下哪个是热力学第一定律？', 'SINGLE_CHOICE', 'HARD', '[\"能量守恒\", \"熵增原理\", \"热平衡\", \"热传导\"]', 'A', '热力学第一定律是能量守恒定律在热力学中的应用。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[43, 44, 45]', 1);
INSERT INTO `questions` VALUES (81, '以下哪个是化学元素？', 'SINGLE_CHOICE', 'EASY', '[\"水\", \"氧气\", \"二氧化碳\", \"盐\"]', 'B', '氧气(O₂)是化学元素。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[37, 38, 39]', 3);
INSERT INTO `questions` VALUES (82, '以下哪个是化学反应？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"燃烧\", \"溶解\", \"蒸发\", \"氧化\"]', '[\"A\", \"D\"]', '燃烧和氧化都是化学反应。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[37, 38]', 3);
INSERT INTO `questions` VALUES (83, '请解释什么是化学键？', 'SHORT_ANSWER', 'MEDIUM', '[]', '化学键是原子间相互作用的力。', '化学键是原子间通过电子共享或转移形成的相互作用力。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[38, 39]', 3);
INSERT INTO `questions` VALUES (84, '以下哪个是酸？', 'SINGLE_CHOICE', 'EASY', '[\"NaOH\", \"HCl\", \"NaCl\", \"H₂O\"]', 'B', 'HCl是盐酸，属于酸类。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[37, 38, 39]', 3);
INSERT INTO `questions` VALUES (85, '以下哪个是碱？', 'SINGLE_CHOICE', 'EASY', '[\"H₂SO₄\", \"NaOH\", \"HCl\", \"HNO₃\"]', 'B', 'NaOH是氢氧化钠，属于碱类。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[37, 38]', 3);
INSERT INTO `questions` VALUES (86, '以下哪个是英语单词？', 'SINGLE_CHOICE', 'EASY', '[\"hello\", \"bonjour\", \"hola\", \"ciao\"]', 'A', 'hello是英语单词。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 15);
INSERT INTO `questions` VALUES (87, '以下哪个是英语时态？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"现在时\", \"过去时\", \"将来时\", \"虚拟时\"]', '[\"A\", \"B\", \"C\"]', '现在时、过去时、将来时都是英语时态。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 15);
INSERT INTO `questions` VALUES (88, '请翻译：Hello, how are you?', 'SHORT_ANSWER', 'EASY', '[]', '你好，你好吗？', '这是基本的英语问候语翻译。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 15);
INSERT INTO `questions` VALUES (89, '以下哪个是英语语法？', 'SINGLE_CHOICE', 'MEDIUM', '[\"主谓宾\", \"定状补\", \"时态\", \"以上都是\"]', 'D', '主谓宾、定状补、时态都是英语语法。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 15);
INSERT INTO `questions` VALUES (94, '以下哪个是SQL语句？', 'SINGLE_CHOICE', 'EASY', '[\"SELECT\", \"INSERT\", \"UPDATE\", \"以上都是\"]', 'D', 'SELECT、INSERT、UPDATE都是SQL语句。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[12, 13]', 9);
INSERT INTO `questions` VALUES (95, '以下哪个是数据库类型？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"MySQL\", \"Oracle\", \"MongoDB\", \"Excel\"]', '[\"A\", \"B\", \"C\"]', 'MySQL、Oracle、MongoDB都是数据库类型。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[13, 14]', 9);
INSERT INTO `questions` VALUES (96, '请解释什么是数据库索引？', 'SHORT_ANSWER', 'HARD', '[]', '数据库索引是提高查询速度的数据结构。', '索引是数据库中用于快速定位数据的数据结构，类似于书籍的目录。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[11, 12, 13]', 9);
INSERT INTO `questions` VALUES (97, '以下哪个是数据库约束？', 'SINGLE_CHOICE', 'MEDIUM', '[\"主键\", \"外键\", \"唯一约束\", \"以上都是\"]', 'D', '主键、外键、唯一约束都是数据库约束。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[11, 12]', 9);
INSERT INTO `questions` VALUES (98, '以下哪个是排序算法？', 'SINGLE_CHOICE', 'EASY', '[\"冒泡排序\", \"快速排序\", \"归并排序\", \"以上都是\"]', 'D', '冒泡排序、快速排序、归并排序都是排序算法。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 11);
INSERT INTO `questions` VALUES (99, '以下哪个是搜索算法？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"二分搜索\", \"线性搜索\", \"深度优先搜索\", \"广度优先搜索\"]', '[\"A\", \"B\", \"C\", \"D\"]', '二分搜索、线性搜索、深度优先搜索、广度优先搜索都是搜索算法。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 11);
INSERT INTO `questions` VALUES (100, '请解释什么是时间复杂度？', 'SHORT_ANSWER', 'HARD', '[]', '时间复杂度是算法执行时间随输入规模增长的趋势。', '时间复杂度用大O记号表示，描述算法在最坏情况下的执行时间。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 11);
INSERT INTO `questions` VALUES (101, '以下哪个是动态规划？', 'SINGLE_CHOICE', 'HARD', '[\"斐波那契数列\", \"背包问题\", \"最长公共子序列\", \"以上都是\"]', 'D', '斐波那契数列、背包问题、最长公共子序列都可以用动态规划解决。', 1, 1, '2025-09-26 15:53:40', '2025-10-31 09:34:39', '[]', 11);
INSERT INTO `questions` VALUES (102, '牛顿第一定律', 'SINGLE_CHOICE', 'EASY', '[\"A. 物体不受力时一定静止\", \"B. 物体受力时一定运动\", \"C. 物体不受力时保持静止或匀速直线运动\", \"D. 物体受力时一定加速运动\"]', 'C', '下列关于牛顿第一定律的说法正确的是：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[44, 45]', 1);
INSERT INTO `questions` VALUES (103, '动量守恒定律', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"A. m1v1 + m2v2 = m1v1\' + m2v2\'\", \"B. 1/2m1v1² + 1/2m2v2² = 1/2m1v1\'² + 1/2m2v2\'²\", \"C. v1 - v2 = v2\' - v1\'\", \"D. 碰撞过程中动能守恒\"]', '[\"A\", \"B\", \"C\", \"D\"]', '两个质量分别为m1和m2的物体发生弹性碰撞，碰撞前速度分别为v1和v2，碰撞后速度分别为v1\'和v2\'，则：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[45, 46]', 1);
INSERT INTO `questions` VALUES (104, '机械能守恒', 'SINGLE_CHOICE', 'MEDIUM', '[\"A. v = √(2gh)\", \"B. v = gh\", \"C. v = 2gh\", \"D. v = √(gh)\"]', 'A', '一个质量为m的物体从高度h处自由落下，落地时速度为v，则：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44, 45]', 1);
INSERT INTO `questions` VALUES (105, '分子动理论', 'SINGLE_CHOICE', 'EASY', '[\"A. 物质由大量分子组成\", \"B. 分子在永不停息地做无规则运动\", \"C. 分子间存在相互作用力\", \"D. 分子运动速度与温度无关\"]', 'D', '下列关于分子动理论的说法错误的是：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44]', 1);
INSERT INTO `questions` VALUES (106, '理想气体状态方程', 'SINGLE_CHOICE', 'MEDIUM', '[\"A. pV = 常数\", \"B. p/V = 常数\", \"C. p + V = 常数\", \"D. p - V = 常数\"]', 'A', '一定质量的理想气体，在等温过程中，压强与体积的关系是：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[44, 45]', 1);
INSERT INTO `questions` VALUES (107, '静电场', 'SINGLE_CHOICE', 'MEDIUM', '[\"A. E = kQ/r\", \"B. E = kQ/r²\", \"C. E = kQ/r³\", \"D. E = kQ²/r²\"]', 'B', '在点电荷Q产生的电场中，距离Q为r处的电场强度大小为：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[45, 46]', 1);
INSERT INTO `questions` VALUES (108, '欧姆定律', 'MULTIPLE_CHOICE', 'EASY', '[\"A. 电阻与电压成正比\", \"B. 电阻与电流成反比\", \"C. 电压与电流成正比\", \"D. 电阻是材料的固有属性\"]', '[\"C\", \"D\"]', '对于线性电阻，下列说法正确的是：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44, 45]', 1);
INSERT INTO `questions` VALUES (109, '当穿过闭合回路的磁通量发生变化时，回路中会产生感应电流，这种现象称为：', 'FILL_BLANK', 'MEDIUM', '[]', '电磁感应', '当穿过闭合回路的磁通量发生变化时，回路中会产生感应电流，这种现象称为：电磁感应', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44]', 1);
INSERT INTO `questions` VALUES (110, '入射角等于反射角，这是光的反射定律。当入射角为30°时，反射角为：', 'FILL_BLANK', 'EASY', '[]', '30°', '入射角等于反射角，这是光的反射定律。当入射角为30°时，反射角为：30°', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[44, 45]', 1);
INSERT INTO `questions` VALUES (111, '光的折射', 'SINGLE_CHOICE', 'MEDIUM', '[\"A. 折射角大于入射角\", \"B. 折射角小于入射角\", \"C. 折射角等于入射角\", \"D. 无法确定\"]', 'B', '光从空气射入水中时，折射角与入射角的关系是：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[45, 46]', 1);
INSERT INTO `questions` VALUES (112, '原子结构', 'SINGLE_CHOICE', 'HARD', '[\"A. 3.4eV\", \"B. 10.2eV\", \"C. 13.6eV\", \"D. 17.0eV\"]', 'B', '氢原子的基态能量为-13.6eV，当电子从n=2能级跃迁到n=1能级时，释放的光子能量为：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44, 45]', 1);
INSERT INTO `questions` VALUES (113, '放射性衰变', 'SINGLE_CHOICE', 'MEDIUM', '[\"A. 原子核完全衰变所需的时间\", \"B. 原子核数量减少一半所需的时间\", \"C. 原子核质量减少一半所需的时间\", \"D. 原子核能量减少一半所需的时间\"]', 'B', '放射性元素的半衰期是指：', 1, 1, '2025-10-09 11:00:59', '2025-10-31 09:34:39', '[43, 44]', 1);
INSERT INTO `questions` VALUES (619, 'Java程序的入口方法名是？', 'SINGLE_CHOICE', 'EASY', '[\"run\", \"main\", \"start\", \"init\"]', 'B', 'Java程序需通过特定方法启动，main方法是唯一的入口方法，固定格式为`public static void main(String[] args)`，其他选项均非入口方法。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[170]', 17);
INSERT INTO `questions` VALUES (620, '以下哪个是Java的基本数据类型？', 'SINGLE_CHOICE', 'EASY', '[\"String\", \"Integer\", \"int\", \"ArrayList\"]', 'C', 'Java基本数据类型包括int、char、boolean等8种，String、Integer是引用数据类型，ArrayList是集合类，均不属于基本数据类型。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[171]', 17);
INSERT INTO `questions` VALUES (621, '用于定义类的Java关键字是？', 'SINGLE_CHOICE', 'EASY', '[\"interface\", \"class\", \"abstract\", \"static\"]', 'B', 'class关键字专门用于声明类，interface用于定义接口，abstract用于修饰抽象类或方法，static用于修饰静态成员，故答案为class。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[172]', 17);
INSERT INTO `questions` VALUES (622, 'Java中“//”符号的作用是？', 'SINGLE_CHOICE', 'EASY', '[\"定义多行注释\", \"定义单行注释\", \"分隔代码块\", \"声明变量\"]', 'B', 'Java中注释分为单行注释（//）、多行注释（/*...*/）和文档注释（/**...*/），“//”仅用于单行注释，其他选项功能均不匹配。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[173]', 17);
INSERT INTO `questions` VALUES (623, '以下能正确声明整型变量a并赋值为5的语句是？', 'SINGLE_CHOICE', 'EASY', '[\"int a = 5;\", \"Integer a = \\\"5\\\";\", \"int a : 5;\", \"a = 5;\"]', 'A', '整型变量声明需指定类型（如int），赋值用“=”，选项A格式正确；选项B将字符串赋值给Integer类型错误，选项C语法错误，选项D未声明变量类型。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[174]', 17);
INSERT INTO `questions` VALUES (624, '以下属于Java算术运算符的是？', 'SINGLE_CHOICE', 'EASY', '[\"==\", \"&amp;&amp;\", \"+\", \"&gt;\"]', 'C', '\"+\"是算术运算符，用于加法运算；“==”是关系运算符（判断相等），“&amp;&amp;”是逻辑运算符（逻辑与），“&gt;”是关系运算符（判断大于）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[175]', 17);
INSERT INTO `questions` VALUES (625, 'if语句中，条件表达式的返回值类型必须是？', 'SINGLE_CHOICE', 'EASY', '[\"int\", \"boolean\", \"String\", \"Object\"]', 'B', 'if语句根据条件表达式的真假执行分支，条件表达式必须返回boolean类型（true或false），其他类型无法作为判断条件。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[176]', 17);
INSERT INTO `questions` VALUES (626, 'Java中循环执行10次的for循环初始化语句可以是？', 'SINGLE_CHOICE', 'EASY', '[\"for (int i = 0; i &lt; 10; i++)\", \"for (int i = 1; i &gt; 10; i++)\", \"for (int i = 0; i &lt;= 10; i++)\", \"for (int i = 10; i &gt; 0; i++)\"]', 'A', '选项A中i从0开始，每次加1，当i&lt;10时执行，共执行10次（i=0到9）；选项B循环条件不成立，选项C执行11次，选项D执行10次但初始化语句格式与“循环执行10次的初始化语句”表述匹配度低于A。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[177]', 17);
INSERT INTO `questions` VALUES (627, '以下哪个方法用于输出内容到控制台？', 'SINGLE_CHOICE', 'EASY', '[\"System.out.print()\", \"System.in.read()\", \"Scanner.next()\", \"String.valueOf()\"]', 'A', 'System.out.print()用于在控制台输出内容；System.in.read()用于读取输入，Scanner.next()用于获取输入，String.valueOf()用于将其他类型转为字符串。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[178]', 17);
INSERT INTO `questions` VALUES (628, '字符串常量存储在Java内存的哪个区域？', 'SINGLE_CHOICE', 'EASY', '[\"堆\", \"栈\", \"方法区（元空间）\", \"本地方法栈\"]', 'C', 'Java中字符串常量（如\"abc\"）默认存储在方法区（JDK8后为元空间）的字符串常量池，堆用于存储对象实例，栈用于存储局部变量，本地方法栈用于本地方法调用。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[196]', 17);
INSERT INTO `questions` VALUES (629, '以下哪个关键字用于修饰常量？', 'SINGLE_CHOICE', 'EASY', '[\"final\", \"static\", \"private\", \"protected\"]', 'A', 'final关键字可修饰变量为常量，一旦赋值不可修改；static修饰静态成员，private和protected修饰访问权限，均无修饰常量的功能。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[179]', 17);
INSERT INTO `questions` VALUES (630, '以下哪个是Java中的布尔值？', 'SINGLE_CHOICE', 'EASY', '[\"0和1\", \"true和false\", \"yes和no\", \"on和off\"]', 'B', 'Java的boolean类型仅有true（真）和false（假）两个取值，不支持用0、1或其他字符表示布尔值。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[180]', 17);
INSERT INTO `questions` VALUES (631, '定义一个方法时，若无需返回值，返回值类型应写为？', 'SINGLE_CHOICE', 'EASY', '[\"void\", \"null\", \"不写\", \"int\"]', 'A', 'Java方法若无需返回值，需明确指定返回值类型为void；null是引用类型的空值，不能作为返回值类型，方法定义必须声明返回值类型（除非是构造方法）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[181]', 17);
INSERT INTO `questions` VALUES (632, '以下哪个是Java的包装类？', 'SINGLE_CHOICE', 'EASY', '[\"int\", \"char\", \"Integer\", \"boolean\"]', 'C', 'Java为基本数据类型提供对应的包装类，int对应Integer，char对应Character，boolean对应Boolean，选项A、B、D均为基本数据类型，非包装类。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[182]', 17);
INSERT INTO `questions` VALUES (633, '以下哪个关键字用于导入包？', 'SINGLE_CHOICE', 'EASY', '[\"package\", \"import\", \"class\", \"interface\"]', 'B', 'import关键字用于导入其他包中的类或接口；package用于声明当前类所在的包，class用于定义类，interface用于定义接口。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[183]', 17);
INSERT INTO `questions` VALUES (634, '以下关于Java数组的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"数组长度可动态修改\", \"数组初始化后长度固定\", \"数组可存储不同类型数据\", \"数组无需初始化即可使用\"]', 'B', 'Java数组初始化后长度固定，不可动态修改；数组只能存储同一类型数据；数组必须初始化（指定长度或赋值）后才能使用，否则会报空指针异常。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[184]', 17);
INSERT INTO `questions` VALUES (635, '以下关于Java继承的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"一个类可继承多个父类\", \"子类可继承父类的private成员\", \"继承通过extends关键字实现\", \"子类不能重写父类的方法\"]', 'C', 'Java是单继承语言，一个类只能继承一个父类；子类无法继承父类的private成员（private成员仅本类可访问）；继承通过extends关键字实现；子类可重写父类的非private方法，实现多态。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[185]', 17);
INSERT INTO `questions` VALUES (636, '以下关于接口的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"接口可包含非抽象方法（JDK8前）\", \"类实现接口需重写所有抽象方法\", \"接口可定义构造方法\", \"接口的成员变量默认是private\"]', 'B', 'JDK8前接口只能包含抽象方法；类实现接口时，若该类非抽象类，必须重写接口的所有抽象方法；接口不能定义构造方法（接口无法实例化）；接口的成员变量默认是public static final。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[185]', 17);
INSERT INTO `questions` VALUES (637, '以下哪个异常属于运行时异常？', 'SINGLE_CHOICE', 'MEDIUM', '[\"IOException\", \"SQLException\", \"NullPointerException\", \"ClassNotFoundException\"]', 'C', '运行时异常继承自RuntimeException，如NullPointerException（空指针异常）；IOException、SQLException、ClassNotFoundException均为受检异常，编译时需显式处理。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[186]', 17);
INSERT INTO `questions` VALUES (638, '以下关于ArrayList的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"ArrayList基于链表实现\", \"ArrayList插入元素效率比LinkedList高\", \"ArrayList支持随机访问（通过索引）\", \"ArrayList是线程安全的\"]', 'C', 'ArrayList基于动态数组实现，支持通过索引随机访问，效率高；LinkedList基于链表实现，插入、删除元素效率比ArrayList高；ArrayList是非线程安全的，多线程环境需手动同步。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[188]', 17);
INSERT INTO `questions` VALUES (639, '以下代码的输出结果是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"true\", \"false\", \"编译错误\", \"运行错误\"]', 'B', 's1指向字符串常量池中的“abc”，s2通过new创建，指向堆内存中的字符串对象；“==”比较引用地址，两者地址不同，故输出false；若比较内容需用equals()方法。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[194]', 17);
INSERT INTO `questions` VALUES (640, '以下哪个关键字用于实现多线程的同步？', 'SINGLE_CHOICE', 'MEDIUM', '[\"synchronized\", \"volatile\", \"static\", \"final\"]', 'A', 'synchronized关键字用于实现线程同步，保证同一时间只有一个线程执行同步代码块；volatile用于保证变量的可见性，static用于修饰静态成员，final用于修饰常量或不可重写的方法。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[187]', 17);
INSERT INTO `questions` VALUES (641, '以下关于构造方法的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"构造方法的返回值类型为void\", \"构造方法名必须与类名相同\", \"类中若未定义构造方法，编译器不会自动生成\", \"一个类只能有一个构造方法\"]', 'B', '构造方法无返回值类型（无需写void）；构造方法名必须与类名完全相同；类中若未定义构造方法，编译器会自动生成默认无参构造方法；一个类可有多个构造方法（构造方法重载）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[185]', 17);
INSERT INTO `questions` VALUES (642, '以下代码的运行结果是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"a=20,b=10\", \"a=10,b=20\", \"a=10,b=10\", \"a=20,b=20\"]', 'B', 'Java中基本数据类型参数传递是值传递，swap方法中修改的是参数x、y的副本，不会影响原变量a、b的值，故a、b仍为10和20。', 1, 1, '2025-10-31 17:29:37', '2025-11-05 09:30:37', '[199]', 17);
INSERT INTO `questions` VALUES (643, '以下关于抽象类的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"抽象类可直接实例化\", \"抽象类中必须包含抽象方法\", \"子类继承抽象类必须重写所有抽象方法（子类非抽象）\", \"抽象类的访问修饰符只能是public\"]', 'C', '抽象类用abstract修饰，无法直接实例化；抽象类中可包含抽象方法和非抽象方法（并非必须有抽象方法）；非抽象子类继承抽象类时，必须重写所有抽象方法；抽象类的访问修饰符可为public、default（无修饰符），不能为private。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[185]', 17);
INSERT INTO `questions` VALUES (644, '以下哪个集合类实现了Set接口？', 'SINGLE_CHOICE', 'MEDIUM', '[\"ArrayList\", \"LinkedList\", \"HashMap\", \"HashSet\"]', 'D', 'HashSet实现了Set接口，特点是无序、不可重复；ArrayList和LinkedList实现了List接口，HashMap实现了Map接口（存储键值对）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[188]', 17);
INSERT INTO `questions` VALUES (645, '以下关于异常处理的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"try块后必须跟catch块\", \"finally块无论是否发生异常都会执行\", \"catch块可捕获所有类型的异常（用Exception）\", \"throw关键字用于声明方法可能抛出的异常\"]', 'B', 'try块后可跟finally块（无catch块），用于释放资源；finally块无论是否发生异常、是否有return，都会执行；catch块用Exception可捕获所有受检异常和运行时异常，但不建议过度捕获（应明确异常类型）；throw用于手动抛出异常对象，throws用于声明方法可能抛出的异常。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[186]', 17);
INSERT INTO `questions` VALUES (646, '以下代码的运行结果是？public class Test {\r\n    public static void main(String[] args) {\r\n        Integer i1 = 127;\r\n        Integer i2 = 127;\r\n        Integer i3 = 128;\r\n        Integer i4 = 128;\r\n        System.out.println(i1 == i2);\r\n        System.out.println(i3 == i4);\r\n    }\r\n}\r\n', 'SINGLE_CHOICE', 'MEDIUM', '[\"true, true\", \"true, false\", \"false, true\", \"false, false\"]', 'B', 'Java中Integer对-128~127的整数有缓存机制，i1和i2均为127，指向缓存中的同一对象，“==”比较为true；i3和i4为128，超出缓存范围，是不同对象，“==”比较为false。', 1, 1, '2025-10-31 17:29:37', '2025-11-05 09:30:54', '[200]', 17);
INSERT INTO `questions` VALUES (647, '以下关于多线程的说法正确的是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"线程启动需调用run()方法\", \"一个进程只能包含一个线程\", \"线程执行完run()方法后进入死亡状态\", \"线程的优先级越高，一定先执行\"]', 'C', '线程启动需调用start()方法（start()会调用run()），直接调用run()只是普通方法调用；一个进程可包含多个线程（多线程）；线程执行完run()方法或因异常退出后，进入死亡（Terminated）状态；线程优先级越高，获得CPU调度的概率越高，但并非一定先执行（取决于CPU调度算法）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[187]', 17);
INSERT INTO `questions` VALUES (648, '以下关于HashMap的说法错误的是？', 'SINGLE_CHOICE', 'HARD', '[\"JDK8后HashMap底层为数组+链表+红黑树\", \"HashMap的key可为null\", \"HashMap是线程安全的\", \"HashMap的默认初始容量为16\"]', 'C', 'JDK8后HashMap底层当链表长度超过8且数组长度超过64时，链表转为红黑树；HashMap的key和value均可为null；HashMap是非线程安全的，多线程环境下需用ConcurrentHashMap；HashMap默认初始容量为16，负载因子为0.75。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[188]', 17);
INSERT INTO `questions` VALUES (649, '以下关于Java内存模型（JMM）的说法正确的是？', 'SINGLE_CHOICE', 'HARD', '[\"JMM保证所有线程对变量的访问是原子性的\", \"volatile关键字可保证变量的原子性\", \"JMM通过happens-before规则保证内存可见性\", \"线程私有内存包括方法区和栈内存\"]', 'C', 'JMM不保证所有变量访问的原子性（如long、double类型的非原子性赋值）；volatile仅保证变量的可见性和禁止指令重排序，不保证原子性；JMM通过happens-before规则（如程序顺序规则、volatile规则）保证内存可见性；线程私有内存包括栈内存、本地方法栈、程序计数器，方法区（元空间）是线程共享的。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[196]', 17);
INSERT INTO `questions` VALUES (650, '以下关于异常链的说法正确的是？', 'SINGLE_CHOICE', 'HARD', '[\"异常链是将多个异常直接抛出，无需关联\", \"可通过Throwable的initCause()方法设置异常的原因\", \"异常链只能包含受检异常\", \"异常链会导致异常信息丢失\"]', 'B', '异常链是将原始异常（原因）关联到新抛出的异常中，便于追踪异常根源；可通过Throwable的initCause()方法或构造方法设置异常的原因；异常链可包含受检异常和运行时异常；异常链能保留原始异常信息，不会导致信息丢失。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[186]', 17);
INSERT INTO `questions` VALUES (651, '以下关于Java泛型的说法错误的是？', 'SINGLE_CHOICE', 'HARD', '[\"泛型可避免类型转换，提高代码安全性\", \"泛型在编译时会进行类型擦除\", \"可创建泛型数组（如List&lt;Integer&gt;[] arr = new List&lt;Integer&gt;[10]）\", \"泛型方法的返回值类型可包含泛型参数\"]', 'C', '泛型通过编译时类型检查，避免强制类型转换，提高安全性；Java泛型采用类型擦除机制，编译后泛型参数被替换为Object或边界类型；Java不允许创建泛型数组（会报编译错误），可通过List&lt;List&lt;Integer&gt;&gt;间接实现；泛型方法的返回值类型可包含泛型参数（如public &lt;T&gt; T getValue(T t)）。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[189]', 17);
INSERT INTO `questions` VALUES (652, '以下代码的运行结果是？public class Test {\r\n    public static void main(String[] args) {\r\n        Thread t = new Thread(() -> {\r\n            try {\r\n                Thread.sleep(1000);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(\"Thread run\");\r\n        });\r\n        t.start();\r\n        t.interrupt();\r\n        System.out.println(\"Main end\");\r\n    }\r\n}\r\n', 'SINGLE_CHOICE', 'HARD', '[\"Main end → Thread run\", \"Thread run → Main end\", \"Main end → InterruptedException异常信息\", \"Thread run → InterruptedException异常信息\"]', 'C', 't.start()启动线程后，主线程调用t.interrupt()中断线程；线程t在sleep()时被中断，会抛出InterruptedException；主线程无需等待子线程，先输出“Main end”，随后子线程输出异常信息，不会执行“Thread run”。', 1, 1, '2025-10-31 17:29:37', '2025-11-05 09:31:19', '[187]', 17);
INSERT INTO `questions` VALUES (653, '以下关于LinkedHashMap的说法正确的是？', 'SINGLE_CHOICE', 'HARD', '[\"LinkedHashMap底层仅基于链表实现\", \"LinkedHashMap无法保持元素的插入顺序\", \"LinkedHashMap可通过accessOrder=true实现LRU缓存\", \"LinkedHashMap是线程安全的\"]', 'C', 'LinkedHashMap继承自HashMap，底层基于数组+链表+红黑树（JDK8后），同时维护双向链表；LinkedHashMap默认保持元素的插入顺序，设置accessOrder=true时保持访问顺序；基于访问顺序的LinkedHashMap可实现LRU（最近最少使用）缓存，移除最久未访问的元素；LinkedHashMap是非线程安全的。', 1, 1, '2025-10-31 17:29:37', '2025-10-31 17:29:37', '[188]', 17);
INSERT INTO `questions` VALUES (654, '以下关于Java垃圾回收（GC）的说法错误的是？', 'SINGLE_CHOICE', 'HARD', '[\"GC负责回收堆内存中无引用的对象\", \"可通过System.gc()强制触发GC\", \"垃圾回收算法包括标记-清除、标记-整理、复制算法\", \"GC会回收栈内存中的局部变量\"]', 'D', 'GC主要回收堆内存中无引用的对象（垃圾对象）；System.gc()可建议JVM执行GC，但JVM不一定立即执行；常见的垃圾回收算法有标记-清除（效率低、有碎片）、标记-整理（无碎片）、复制算法（适合新生代）；栈内存中的局部变量随方法调用结束自动出栈，无需GC回收。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[198]', 17);
INSERT INTO `questions` VALUES (655, '以下关于接口和抽象类的区别错误的是？', 'SINGLE_CHOICE', 'HARD', '[\"抽象类可包含非抽象方法，接口（JDK8前）只能包含抽象方法\", \"一个类可实现多个接口，只能继承一个抽象类\", \"抽象类的成员变量默认是private，接口的成员变量默认是public static final\", \"抽象类可定义构造方法，接口不能定义构造方法\"]', 'C', '抽象类可包含非抽象方法，JDK8前接口只能包含抽象方法（JDK8后可包含默认方法、静态方法）；Java单继承、多实现，一个类只能继承一个抽象类，可实现多个接口；抽象类的成员变量无默认访问修饰符（默认是default），可定义为public、private等，接口的成员变量默认是public static final；抽象类可定义构造方法（用于子类初始化），接口无法实例化，不能定义构造方法。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (656, '以下关于Callable和Runnable的区别正确的是？', 'SINGLE_CHOICE', 'HARD', '[\"Runnable可返回结果，Callable不能返回结果\", \"Runnable可抛出受检异常，Callable不能\", \"Callable的call()方法有返回值，Runnable的run()方法无返回值\", \"两者均可通过Thread直接启动\"]', 'C', 'Callable的call()方法有返回值（通过Future获取），Runnable的run()方法无返回值；Callable的call()方法可抛出受检异常，Runnable的run()方法不能（只能抛出运行时异常）；Callable需通过FutureTask包装后，再传入Thread启动，不能直接通过Thread启动，Runnable可直接传入Thread启动。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[187]', 17);
INSERT INTO `questions` VALUES (657, '以下关于Java IO流的说法错误的是？', 'SINGLE_CHOICE', 'HARD', '[\"字节流以字节为单位读写数据，字符流以字符为单位读写数据\", \"FileInputStream是字节输入流，FileReader是字符输入流\", \"缓冲流（如BufferedInputStream）可提高读写效率\", \"字节流可读写任意文件，字符流也可读写任意文件\"]', 'D', '字节流以字节（8位）为单位，适用于读写任意文件（如图片、视频）；字符流以字符（如UTF-8中1字符=3字节）为单位，仅适用于读写文本文件；若用字符流读写非文本文件（如图片），会导致文件损坏；FileInputStream是字节输入流，FileReader是字符输入流；缓冲流通过缓冲区减少IO次数，提高读写效率。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[190]', 17);
INSERT INTO `questions` VALUES (658, '以下属于Java基本数据类型的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"int\", \"char\", \"String\", \"boolean\", \"Double\"]', 'A,B,D', 'Java基本数据类型包括int（整数）、char（字符）、boolean（布尔）等8种；String是引用数据类型（类），Double是包装类（引用类型），均不属于基本数据类型。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[171]', 17);
INSERT INTO `questions` VALUES (659, '以下属于Java循环结构的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"for循环\", \"while循环\", \"do-while循环\", \"if-else\", \"switch-case\"]', 'A,B,C', 'Java循环结构用于重复执行代码块，包括for、while、do-while；if-else和switch-case是分支结构，用于根据条件执行不同代码块。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[177]', 17);
INSERT INTO `questions` VALUES (660, '以下关于Java字符串的说法正确的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"String是不可变的（immutable）\", \"String可通过“+”进行拼接\", \"String的equals()方法用于比较引用地址\", \"StringBuffer是线程安全的\", \"StringBuilder比StringBuffer效率高（单线程）\"]', 'A,B,D,E', 'String对象创建后内容不可变（修改会创建新对象）；String可通过“+”拼接（编译后转为StringBuilder）；String的equals()方法用于比较内容，“==”比较引用地址；StringBuffer的方法加了synchronized，是线程安全的；StringBuilder无同步锁，单线程下效率比StringBuffer高。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[191]', 17);
INSERT INTO `questions` VALUES (661, '以下属于Java关键字的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"class\", \"public\", \"main\", \"static\", \"String\"]', 'A,B,D', 'class（定义类）、public（访问修饰符）、static（静态修饰符）均为Java关键字；main是方法名（入口方法），String是类名，均非关键字。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[192]', 17);
INSERT INTO `questions` VALUES (662, '以下关于Java方法的说法正确的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"方法名必须符合标识符规则\", \"方法参数列表可为空（无参方法）\", \"方法必须有返回值\", \"方法可在类中嵌套定义\", \"方法调用需传递与参数列表匹配的参数\"]', 'A,B,E', '方法名需符合Java标识符规则（字母、数字、下划线、$，不能以数字开头）；方法可无参数（空参数列表）；方法可无返回值（返回值类型为void）；Java不支持方法嵌套定义（方法只能定义在类中）；方法调用时，实参类型、个数需与形参列表匹配。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[201]', 17);
INSERT INTO `questions` VALUES (663, '以下关于Java数组的说法正确的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"数组可存储同一类型的数据\", \"数组长度通过length属性获取\", \"数组初始化时必须指定长度\", \"可通过索引访问数组元素\", \"数组属于引用数据类型\"]', 'A,B,D,E', '数组只能存储同一类型的数据（如int数组仅存int值）；数组长度通过“数组名.length”获取；数组初始化有两种方式：指定长度（如int[] arr = new int[5]）或直接赋值（如int[] arr = {1,2,3}，无需显式指定长度）；数组元素通过索引（从0开始）访问；数组是引用数据类型，存储在堆内存中。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[184]', 17);
INSERT INTO `questions` VALUES (664, '以下关于Java访问修饰符的说法正确的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"public修饰的成员可在任意地方访问\", \"private修饰的成员仅在本类中访问\", \"protected修饰的成员可在本包和子类中访问\", \"default（无修饰符）修饰的成员可在任意地方访问\", \"访问修饰符可用于修饰类、成员变量、方法\"]', 'A,B,C,E', 'public是最宽松的修饰符，成员可在任意类访问；private是最严格的修饰符，成员仅本类可访问；protected修饰的成员可在本包内的类和不同包的子类中访问；default修饰的成员仅可在本包内访问；访问修饰符可修饰类（public、default）、成员变量、方法（public、private、protected、default）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[179]', 17);
INSERT INTO `questions` VALUES (665, '以下属于Java面向对象特性的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"封装\", \"继承\", \"多态\", \"抽象\", \"接口\"]', 'A,B,C,D', 'Java面向对象的核心特性包括封装（隐藏内部细节）、继承（复用父类代码）、多态（同一行为不同实现）、抽象（提取共性，如抽象类、接口）；接口是实现抽象和多态的工具，并非特性本身。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (666, '以下关于Java接口的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"接口可继承多个接口\", \"类实现接口需重写所有抽象方法（非抽象类）\", \"JDK8后接口可包含默认方法（default修饰）\", \"接口的成员变量默认是public static final\", \"接口可直接实例化\"]', 'A,B,C,D', 'Java接口支持多继承（一个接口可继承多个接口）；非抽象类实现接口时，必须重写所有抽象方法；JDK8后接口新增默认方法（default修饰，有方法体）和静态方法（static修饰）；接口的成员变量默认是public static final（必须初始化）；接口是抽象类型，无法直接实例化，需通过实现类实例化。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (667, '以下关于Java异常的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"Throwable是所有异常和错误的父类\", \"Exception包括受检异常和运行时异常\", \"RuntimeException是受检异常\", \"Error一般无需程序员处理\", \"可通过try-catch-finally处理异常\"]', 'A,B,D,E', 'Java中所有异常和错误都继承自Throwable类；Exception是Throwable的子类，包括受检异常（如IOException）和运行时异常（如NullPointerException）；RuntimeException是未受检异常，编译时无需显式处理；Error是系统级错误（如OutOfMemoryError），由JVM抛出，一般无需程序员处理；异常可通过try-catch捕获处理，finally用于释放资源。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[186]', 17);
INSERT INTO `questions` VALUES (668, '以下关于Java集合框架的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"Collection接口是单列集合的根接口\", \"Map接口用于存储键值对（Key-Value）\", \"List接口的实现类有序、可重复\", \"Set接口的实现类无序、不可重复\", \"HashMap实现了List接口\"]', 'A,B,C,D', 'Java集合框架中，Collection是单列集合（存储单个元素）的根接口，Map是双列集合（存储键值对）的根接口；List接口的实现类（如ArrayList、LinkedList）具有有序（插入顺序）、可重复的特点；Set接口的实现类（如HashSet、TreeSet）具有无序（HashSet）或有序（TreeSet，自然排序）、不可重复的特点；HashMap实现了Map接口，未实现List接口。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[188]', 17);
INSERT INTO `questions` VALUES (669, '以下关于Java多线程的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"实现多线程可通过继承Thread类\", \"实现多线程可通过实现Runnable接口\", \"Thread类实现了Runnable接口\", \"线程启动需调用start()方法\", \"多线程环境下共享变量可能存在线程安全问题\"]', 'A,B,C,D,E', 'Java实现多线程的两种核心方式是继承Thread类（重写run()）和实现Runnable接口（实现run()）；Thread类实现了Runnable接口，其run()方法会调用Runnable的run()；线程必须通过start()方法启动（start()会创建新线程并调用run()），直接调用run()是普通方法调用；多线程共享变量时，若未同步，会出现线程安全问题（如数据不一致）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[187]', 17);
INSERT INTO `questions` VALUES (670, '以下关于Java构造方法的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"构造方法名必须与类名相同\", \"构造方法无返回值类型\", \"类中若未定义构造方法，编译器生成默认无参构造\", \"构造方法可重载（多个构造方法）\", \"子类构造方法默认调用父类的无参构造\"]', 'A,B,C,D,E', '构造方法的核心特点是名称与类名一致，无返回值类型（无需写void）；若类中未显式定义构造方法，编译器会自动生成一个默认无参构造方法；一个类可定义多个构造方法（参数列表不同），即构造方法重载；子类构造方法执行时，默认先调用父类的无参构造（通过super()），若父类无无参构造，子类需显式调用父类的有参构造。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (671, '以下关于Java泛型的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"泛型可提高代码的复用性\", \"泛型可避免强制类型转换\", \"泛型参数在编译时会被擦除\", \"可定义泛型类、泛型接口、泛型方法\", \"泛型可用于数组（直接创建泛型数组）\"]', 'A,B,C,D', '泛型通过参数化类型，使代码可适配多种数据类型，提高复用性；泛型在编译时进行类型检查，避免运行时的强制类型转换；Java泛型采用类型擦除机制，编译后泛型参数被替换为Object或边界类型；泛型可用于类（如class List&lt;T&gt;）、接口（如interface Map&lt;K,V&gt;）、方法（如public &lt;T&gt; T get()）；Java不允许直接创建泛型数组（如List&lt;Integer&gt;[] arr = new List&lt;Integer&gt;[10]会报编译错误），需间接实现。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[189]', 17);
INSERT INTO `questions` VALUES (672, '以下关于Java IO流的说法正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"字节流包括InputStream和OutputStream\", \"字符流包括Reader和Writer\", \"缓冲流可提高IO效率\", \"转换流（如InputStreamReader）可实现字节流与字符流的转换\", \"File类是IO流的核心类，用于读写文件\"]', 'A,B,C,D', 'Java IO流分为字节流和字符流，字节流的顶层父类是InputStream（输入）和OutputStream（输出），字符流的顶层父类是Reader（输入）和Writer（输出）；缓冲流（如BufferedInputStream、BufferedReader）通过缓冲区减少IO操作次数，提高效率；转换流InputStreamReader（字节转字符）和OutputStreamWriter（字符转字节），用于处理字节流与字符流的转换；File类用于表示文件或目录的路径，本身不具备读写功能，读写需通过IO流（如FileInputStream、FileReader）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[190]', 17);
INSERT INTO `questions` VALUES (673, '以下关于HashMap和Hashtable的区别正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"HashMap是线程安全的，Hashtable是非线程安全的\", \"HashMap的key和value均可为null，Hashtable不可\", \"HashMap的默认初始容量为16，Hashtable为11\", \"HashMap的负载因子为0.75，Hashtable为0.75\", \"HashMap底层（JDK8后）是数组+链表+红黑树，Hashtable是数组+链表\"]', 'B,C,D,E', 'HashMap是非线程安全的，Hashtable的方法加了synchronized，是线程安全的；HashMap允许key和value为null（仅一个key为null），Hashtable不允许key或value为null；HashMap默认初始容量为16，Hashtable为11；两者默认负载因子均为0.75；JDK8后HashMap底层当链表长度超过8且数组长度超过64时转为红黑树，Hashtable底层始终是数组+链表，无红黑树优化。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[188]', 17);
INSERT INTO `questions` VALUES (674, '以下关于Java线程同步的说法正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"synchronized可修饰方法和代码块\", \"ReentrantLock（重入锁）可替代synchronized实现同步\", \"volatile关键字可保证线程同步（原子性）\", \"ThreadLocal可通过线程私有变量避免线程安全问题\", \"同步会导致线程阻塞，可能引发死锁\"]', 'A,B,D,E', 'synchronized可修饰实例方法、静态方法和代码块（同步对象）；ReentrantLock是JDK5后提供的锁机制，功能比synchronized更灵活（如可中断、可超时），可替代synchronized实现同步；volatile仅保证变量的可见性和禁止指令重排序，不保证原子性，无法实现线程同步；ThreadLocal为每个线程提供独立的变量副本，线程操作各自副本，避免共享变量的线程安全问题；同步（如synchronized、ReentrantLock）会使线程等待锁，导致阻塞，若多个线程互相等待对方的锁，会引发死锁。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[187]', 17);
INSERT INTO `questions` VALUES (675, '以下关于Java垃圾回收算法的说法正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"标记-清除算法分为标记和清除两个阶段，效率低且有内存碎片\", \"标记-整理算法可解决标记-清除的内存碎片问题\", \"复制算法适合用于新生代（如Eden区和Survivor区）\", \"分代收集算法将堆内存分为新生代和老年代，采用不同回收算法\", \"G1垃圾回收器采用分代收集算法，同时支持Region分区\"]', 'A,B,C,D,E', '标记-清除算法先标记垃圾对象，再清除，缺点是效率低、产生内存碎片；标记-整理算法在标记后，将存活对象移动到一端，清除另一端，解决内存碎片问题；复制算法将内存分为两块，每次使用一块，回收时复制存活对象到另一块，适合新生代（存活对象少，复制成本低）；分代收集算法根据对象存活周期，将堆分为新生代（用复制算法）和老年代（用标记-清除或标记-整理算法）；G1（Garbage-First）回收器是分代收集算法的延伸，将堆分为多个Region分区，优先回收垃圾多的Region，兼顾吞吐量和响应时间。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[198]', 17);
INSERT INTO `questions` VALUES (676, '以下关于Java接口和抽象类的区别正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"抽象类可包含非抽象方法，接口（JDK8前）只能包含抽象方法\", \"抽象类可定义构造方法，接口不能\", \"一个类可实现多个接口，只能继承一个抽象类\", \"抽象类的成员变量可修改，接口的成员变量默认是public static final（不可修改）\", \"抽象类体现“is-a”关系，接口体现“has-a”关系\"]', 'A,B,C,D,E', '抽象类可包含抽象方法和非抽象方法，JDK8前接口只能包含抽象方法（JDK8后可包含默认方法、静态方法）；抽象类可定义构造方法（用于子类初始化），接口无法实例化，不能定义构造方法；Java单继承、多实现，一个类只能继承一个抽象类，可实现多个接口；抽象类的成员变量无默认修饰符，可修改（如public int a = 10; a = 20;），接口的成员变量默认是public static final，初始化后不可修改；抽象类用于封装子类的共性，体现“is-a”（子类是父类的一种）关系，接口用于定义行为规范，体现“has-a”（类具有接口的行为）关系。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (677, '以下关于Java并发集合的说法正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"ConcurrentHashMap是线程安全的HashMap\", \"CopyOnWriteArrayList适合读多写少的场景\", \"ConcurrentLinkedQueue是线程安全的队列，基于链表实现\", \"BlockingQueue支持阻塞的插入和移除操作（如take()、put()）\", \"并发集合的效率比普通集合（加同步锁）低\"]', 'A,B,C,D', 'ConcurrentHashMap是线程安全的HashMap，JDK8后采用CAS+同步锁实现，效率高于Hashtable；CopyOnWriteArrayList在写操作时复制底层数组，读操作无锁，适合读多写少的场景；ConcurrentLinkedQueue是基于链表的无界线程安全队列，采用CAS实现，无锁；BlockingQueue（如ArrayBlockingQueue、LinkedBlockingQueue）支持阻塞操作，当队列满时put()阻塞，队列空时take()阻塞；并发集合（如ConcurrentHashMap）通过优化锁机制（如分段锁、CAS），效率比普通集合（如HashMap加synchronized）高。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[188]', 17);
INSERT INTO `questions` VALUES (678, 'Java程序的入口方法完整声明是______。', 'FILL_BLANK', 'EASY', NULL, 'public static void main(String[] args)', 'Java程序需通过固定格式的main方法启动，访问修饰符为public，静态修饰符static（无需实例化类），无返回值（void），参数为String数组（接收命令行参数）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[170]', 17);
INSERT INTO `questions` VALUES (679, '声明一个长度为5的字符串数组，语法是______。', 'FILL_BLANK', 'EASY', NULL, 'String[] arr = new String[5]; 或 String arr[] = new String[5];', 'Java数组声明格式为“数据类型[] 数组名 = new 数据类型[长度]”或“数据类型 数组名[] = new 数据类型[长度]”，字符串数组的数据类型为String，长度为5时按上述格式声明。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[193]', 17);
INSERT INTO `questions` VALUES (680, 'Java中，用于比较两个字符串内容是否相等的方法是______。', 'FILL_BLANK', 'EASY', NULL, 'equals()', 'String类的equals()方法用于比较字符串内容是否相等；“==”用于比较引用地址，不能比较内容，故需用equals()方法。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[194]', 17);
INSERT INTO `questions` VALUES (681, '用于修饰静态成员的关键字是______。', 'FILL_BLANK', 'EASY', NULL, 'static', 'static关键字用于修饰静态成员（静态变量、静态方法），静态成员属于类，不属于对象，可通过“类名.成员名”直接访问。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[179]', 17);
INSERT INTO `questions` VALUES (682, 'Java中，基本数据类型int的默认值是______。', 'FILL_BLANK', 'EASY', NULL, '0', 'Java中基本数据类型有默认值，int类型默认值为0，char为\'\\u0000\'，boolean为false，引用数据类型默认值为null。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[195]', 17);
INSERT INTO `questions` VALUES (683, '定义一个抽象方法时，需使用的关键字是______。', 'FILL_BLANK', 'EASY', NULL, 'abstract', '抽象方法是无方法体的方法，需用abstract关键字修饰，且只能定义在抽象类或接口中（JDK8前接口方法默认抽象，无需写abstract）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (684, '实现多线程的两种核心方式是继承______类和实现______接口。', 'FILL_BLANK', 'MEDIUM', NULL, 'Thread；Runnable', 'Java实现多线程的两种方式：一是继承Thread类，重写run()方法（线程执行逻辑）；二是实现Runnable接口，实现run()方法，再将Runnable对象传入Thread类的构造方法启动线程。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[187]', 17);
INSERT INTO `questions` VALUES (685, 'Java集合框架中，存储键值对的顶层接口是______。', 'FILL_BLANK', 'MEDIUM', NULL, 'Map', 'Java集合框架分为Collection（单列集合）和Map（双列集合），Map接口用于存储键值对（Key-Value），每个键唯一，常见实现类有HashMap、TreeMap等。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[188]', 17);
INSERT INTO `questions` VALUES (686, '异常处理中，用于手动抛出异常对象的关键字是______，用于声明方法可能抛出异常的关键字是______。', 'FILL_BLANK', 'MEDIUM', NULL, 'throw；throws', 'throw关键字用于在方法内部手动抛出异常对象（如throw new NullPointerException()）；throws关键字用于在方法声明处声明该方法可能抛出的异常类型（如public void test() throws IOException）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[186]', 17);
INSERT INTO `questions` VALUES (687, 'Java中，用于将基本数据类型转为对应的包装类的过程称为______，反之称为______。', 'FILL_BLANK', 'MEDIUM', NULL, '装箱；拆箱', '装箱是将基本数据类型转为包装类（如int→Integer），可通过new Integer(10)或自动装箱（Integer i = 10）；拆箱是将包装类转为基本数据类型（如Integer→int），可通过i.intValue()或自动拆箱（int a = i）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[182]', 17);
INSERT INTO `questions` VALUES (688, '接口中定义的方法，在JDK8之前默认的访问修饰符是______。', 'FILL_BLANK', 'MEDIUM', NULL, 'public abstract', 'JDK8之前，接口中的方法必须是抽象方法，默认访问修饰符为public abstract（可省略不写）；JDK8后接口可包含默认方法（default修饰）和静态方法（static修饰），抽象方法仍默认public abstract。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[185]', 17);
INSERT INTO `questions` VALUES (689, 'HashMap中，用于计算key的哈希值并确定数组索引的方法是______。', 'FILL_BLANK', 'HARD', NULL, 'hash()', 'HashMap中，先通过key的hashCode()方法获取哈希码，再调用hash()方法对哈希码进行二次哈希（减少哈希冲突），最后通过“(数组长度-1) &amp; 哈希值”计算数组索引。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[188]', 17);
INSERT INTO `questions` VALUES (690, 'Java内存模型中，保证线程间变量可见性的关键字是______。', 'FILL_BLANK', 'HARD', NULL, 'volatile', 'volatile关键字的核心作用是保证变量的可见性（一个线程修改变量后，其他线程能立即看到修改后的值）和禁止指令重排序，但不保证原子性，无法解决线程安全问题（如i++）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[196]', 17);
INSERT INTO `questions` VALUES (691, '泛型类的定义格式是：class 类名&lt;______&gt; { ... }。', 'FILL_BLANK', 'HARD', NULL, '泛型参数列表', '泛型类通过参数化类型实现通用性，定义格式为“class 类名&lt;泛型参数&gt;”，泛型参数用大写字母表示（如T、K、V），例如class List&lt;T&gt;，其中&lt;T&gt;是泛型参数列表（单个参数）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[189]', 17);
INSERT INTO `questions` VALUES (692, '线程的生命周期中，调用start()方法后线程进入______状态，获取CPU调度后进入______状态。', 'FILL_BLANK', 'HARD', NULL, '就绪（Runnable）；运行（Running）', '线程生命周期包括新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Terminated）；调用start()方法后，线程进入就绪状态（等待CPU调度）；CPU调度后，线程执行run()方法，进入运行状态。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[187]', 17);
INSERT INTO `questions` VALUES (693, 'Java是一种面向对象的编程语言。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'Java是纯面向对象的编程语言，支持封装、继承、多态、抽象等面向对象核心特性，一切事物皆对象（除基本数据类型，可通过包装类转为对象）。', 1, 1, '2025-10-31 17:29:38', '2025-10-31 17:29:38', '[197]', 17);
INSERT INTO `questions` VALUES (694, 'Java中的方法可以有多个返回值。', 'TRUE_FALSE', 'EASY', NULL, 'false', 'Java中的方法语法上只能有一个返回值（返回值类型为void时无返回值）；若需返回多个数据，可通过返回对象、集合或数组间接实现，但并非多个返回值。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[181]', 17);
INSERT INTO `questions` VALUES (695, 'String类是不可变的（immutable），即创建后内容无法修改。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'String类的底层是char数组（JDK9后为byte数组），且被final修饰，无法修改；当对String进行“修改”（如拼接、替换）时，会创建新的String对象，原对象内容不变。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[191]', 17);
INSERT INTO `questions` VALUES (696, '基本数据类型int的取值范围是-2³¹~2³¹-1。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'Java中int类型占4个字节（32位），取值范围为-2³¹（-2147483648）到2³¹-1（2147483647），超出范围需用long类型。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[195]', 17);
INSERT INTO `questions` VALUES (697, '接口中的成员变量默认是public static final。', 'TRUE_FALSE', 'EASY', NULL, 'true', '接口中的成员变量无论是否显式声明，默认都是public static final（必须初始化，且初始化后不可修改），这是接口的语法规则。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[185]', 17);
INSERT INTO `questions` VALUES (698, 'Java程序必须包含main方法才能运行。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'main方法是Java程序的唯一入口，JVM通过调用main方法启动程序；若类中无main方法，程序无法运行（会报NoSuchMethodError: main）。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[170]', 17);
INSERT INTO `questions` VALUES (699, 'static修饰的方法可以访问非static成员变量。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', 'static修饰的方法属于类，在类加载时就存在；非static成员变量属于对象，需创建对象后才存在；类方法（static方法）无法访问对象的成员变量，否则会报编译错误。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[179]', 17);
INSERT INTO `questions` VALUES (700, '接口可以包含构造方法。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '接口是抽象类型，用于定义行为规范，无法实例化（无对象创建过程），因此不能包含构造方法（构造方法用于对象初始化）；抽象类可包含构造方法，用于子类初始化。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[185]', 17);
INSERT INTO `questions` VALUES (701, 'ArrayList的底层基于数组实现，LinkedList的底层基于链表实现。', 'TRUE_FALSE', 'MEDIUM', NULL, 'true', 'ArrayList基于动态数组实现，支持随机访问（通过索引），效率高；LinkedList基于双向链表实现，插入、删除元素效率高（无需移动元素），两者底层数据结构不同，适用场景不同。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[188]', 17);
INSERT INTO `questions` VALUES (702, '受检异常（Checked Exception）必须显式处理（捕获或声明），否则无法通过编译。', 'TRUE_FALSE', 'MEDIUM', NULL, 'true', '受检异常继承自Exception（非RuntimeException），如IOException、SQLException，编译时编译器会强制要求处理（用try-catch捕获，或用throws声明抛出），否则编译报错；运行时异常无需显式处理。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[186]', 17);
INSERT INTO `questions` VALUES (703, '子类可以重写父类的private方法。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', 'private修饰的方法仅在父类中可访问，子类无法继承父类的private方法；重写的前提是子类能继承父类的方法，因此子类无法重写父类的private方法，若子类定义与父类private方法同名的方法，属于子类的新方法，并非重写。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[185]', 17);
INSERT INTO `questions` VALUES (704, 'HashMap是线程安全的，在多线程环境下可直接使用。', 'TRUE_FALSE', 'HARD', NULL, 'false', 'HashMap是非线程安全的，多线程环境下同时进行put、remove等操作，可能出现链表环（JDK7及前）、数据丢失等问题；多线程环境需使用线程安全的ConcurrentHashMap，或对HashMap加同步锁（如Collections.synchronizedMap()）。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[188]', 17);
INSERT INTO `questions` VALUES (705, 'Java的垃圾回收机制（GC）会自动回收所有内存，无需程序员关注内存管理。', 'TRUE_FALSE', 'HARD', NULL, 'false', 'GC仅负责回收堆内存中无引用的对象，无法回收栈内存（局部变量随方法结束出栈）、方法区（元空间）的内存；若存在对象引用泄漏（如长期持有无用对象的引用），GC无法回收，会导致内存泄漏，因此程序员仍需关注内存管理（如避免引用泄漏）。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[198]', 17);
INSERT INTO `questions` VALUES (706, 'volatile关键字可以保证变量操作的原子性（如i++）。', 'TRUE_FALSE', 'HARD', NULL, 'false', 'volatile关键字的作用是保证变量的可见性和禁止指令重排序，无法保证原子性；i++操作分为“读取i值→i+1→写入i”三步，volatile无法保证这三步的原子性，多线程环境下仍会出现数据不一致，需用synchronized或AtomicInteger保证原子性。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[196]', 17);
INSERT INTO `questions` VALUES (707, '分代收集算法将堆内存分为新生代和老年代，新生代采用复制算法，老年代采用标记-整理算法。', 'TRUE_FALSE', 'HARD', NULL, 'true', '分代收集算法根据对象存活周期划分堆内存：新生代（对象存活时间短，存活少）采用复制算法（效率高），分为Eden区和两个Survivor区；老年代（对象存活时间长，存活多）采用标记-清除或标记-整理算法（标记-整理无内存碎片，更适合老年代）。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[198]', 17);
INSERT INTO `questions` VALUES (708, '简述Java中重载（Overload）和重写（Override）的区别。', 'SHORT_ANSWER', 'EASY', NULL, '重载（Overload）和重写（Override）是Java中实现多态的两种方式，核心区别如下：\n1. 发生位置：重载发生在同一个类中，重写发生在父子类之间（或接口与实现类之间）；\n2. 方法签名：重载要求方法名相同，参数列表（参数类型、个数、顺序）不同，返回值类型、访问修饰符可不同；重写要求方法名、参数列表、返回值类型（子类返回值可兼容父类）完全相同；\n3. 访问修饰符：重载对访问修饰符无限制；重写时子类方法的访问修饰符不能比父类更严格（如父类为public，子类不能为private）；\n4. 异常处理：重载对异常抛出无限制；重写时子类方法抛出的异常不能比父类更宽泛（可抛出子类异常或不抛出）；\n5. 多态类型：重载是编译时多态（编译器根据参数列表确定调用的方法）；重写是运行时多态（JVM根据对象实际类型确定调用的方法）。', '重载（Overload）和重写（Override）是Java中实现多态的两种方式，核心区别如下：\n1. 发生位置：重载发生在同一个类中，重写发生在父子类之间（或接口与实现类之间）；\n2. 方法签名：重载要求方法名相同，参数列表（参数类型、个数、顺序）不同，返回值类型、访问修饰符可不同；重写要求方法名、参数列表、返回值类型（子类返回值可兼容父类）完全相同；\n3. 访问修饰符：重载对访问修饰符无限制；重写时子类方法的访问修饰符不能比父类更严格（如父类为public，子类不能为private）；\n4. 异常处理：重载对异常抛出无限制；重写时子类方法抛出的异常不能比父类更宽泛（可抛出子类异常或不抛出）；\n5. 多态类型：重载是编译时多态（编译器根据参数列表确定调用的方法）；重写是运行时多态（JVM根据对象实际类型确定调用的方法）。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[185]', 17);
INSERT INTO `questions` VALUES (709, '请说明Java中值传递和引用传递的区别，并举例说明。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'Java中只有值传递，不存在引用传递，区别主要体现在参数类型为基本数据类型和引用数据类型时的传递方式：\n1. 基本数据类型的值传递：\n   - 传递的是值的副本，方法内部修改副本的值，不会影响原变量；\n   - 示例：\n     ```java\n     public static void main(String[] args) {\n         int a = 10;\n         change(a);\n         System.out.println(a); // 输出10，原变量未变\n     }\n     public static void change(int x) {\n         x = 20; // 修改的是副本x\n     }\n     ```\n2. 引用数据类型的值传递：\n   - 传递的是对象引用的副本（引用指向堆内存中的对象），方法内部通过副本引用修改对象的属性，会影响原对象；但修改副本引用本身（如指向新对象），不会影响原引用；\n   - 示例1（修改对象属性，影响原对象）：\n     ```java\n     class Person {\n         int age;\n     }\n     public static void main(String[] args) {\n         Person p = new Person();\n         p.age = 18;\n         changeAge(p);\n         System.out.println(p.age); // 输出20，原对象属性被修改\n     }\n     public static void changeAge(Person obj) {\n         obj.age = 20; // 通过副本引用修改原对象属性\n     }\n     ```\n   - 示例2（修改引用本身，不影响原引用）：\n     ```java\n     public static void main(String[] args) {\n         Person p = new Person();\n         p.age = 18;\n         changeRef(p);\n         System.out.println(p.age); // 输出18，原引用未变\n     }\n     public static void changeRef(Person obj) {\n         obj = new Person(); // 副本引用指向新对象\n         obj.age = 20;\n     }\n     ```', 'Java中只有值传递，不存在引用传递，区别主要体现在参数类型为基本数据类型和引用数据类型时的传递方式：\n1. 基本数据类型的值传递：\n   - 传递的是值的副本，方法内部修改副本的值，不会影响原变量；\n   - 示例：\n     ```java\n     public static void main(String[] args) {\n         int a = 10;\n         change(a);\n         System.out.println(a); // 输出10，原变量未变\n     }\n     public static void change(int x) {\n         x = 20; // 修改的是副本x\n     }\n     ```\n2. 引用数据类型的值传递：\n   - 传递的是对象引用的副本（引用指向堆内存中的对象），方法内部通过副本引用修改对象的属性，会影响原对象；但修改副本引用本身（如指向新对象），不会影响原引用；\n   - 示例1（修改对象属性，影响原对象）：\n     ```java\n     class Person {\n         int age;\n     }\n     public static void main(String[] args) {\n         Person p = new Person();\n         p.age = 18;\n         changeAge(p);\n         System.out.println(p.age); // 输出20，原对象属性被修改\n     }\n     public static void changeAge(Person obj) {\n         obj.age = 20; // 通过副本引用修改原对象属性\n     }\n     ```\n   - 示例2（修改引用本身，不影响原引用）：\n     ```java\n     public static void main(String[] args) {\n         Person p = new Person();\n         p.age = 18;\n         changeRef(p);\n         System.out.println(p.age); // 输出18，原引用未变\n     }\n     public static void changeRef(Person obj) {\n         obj = new Person(); // 副本引用指向新对象\n         obj.age = 20;\n     }\n     ```', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[199]', 17);
INSERT INTO `questions` VALUES (710, '简述Java集合框架的体系结构，并说明常用集合类的特点。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'Java集合框架用于存储和操作数据，核心分为Collection（单列集合）和Map（双列集合）两大体系，底层基于接口和实现类的设计模式：\n### 一、体系结构\n1. Collection接口（单列集合，存储单个元素）：\n   - 子接口1：List（有序、可重复，元素有索引）；\n   - 子接口2：Set（无序、不可重复，无索引）；\n   - 子接口3：Queue（队列，先进先出，FIFO）。\n2. Map接口（双列集合，存储键值对Key-Value）：\n   - 键唯一，值可重复；\n   - 子接口：SortedMap（键有序，如TreeMap）。\n### 二、常用集合类特点\n1. List接口实现类：\n   - ArrayList：基于动态数组实现，随机访问效率高（通过索引），插入/删除（非末尾）效率低（需移动元素），非线程安全；\n   - LinkedList：基于双向链表实现，插入/删除效率高（无需移动元素），随机访问效率低（需遍历链表），非线程安全；\n   - Vector：基于数组实现，线程安全（方法加synchronized），效率低，已被ArrayList替代。\n2. Set接口实现类：\n   - HashSet：基于HashMap实现，无序、不可重复，判断重复基于hashCode()和equals()，非线程安全；\n   - LinkedHashSet：继承HashSet，维护双向链表，保证插入顺序，效率略低于HashSet；\n   - TreeSet：基于TreeMap实现，键有序（自然排序或自定义比较器），不可重复，查询效率为O(log n)。\n3. Map接口实现类：\n   - HashMap：基于数组+链表+红黑树（JDK8后），无序、键唯一，键和值均可为null，非线程安全，效率高；\n   - LinkedHashMap：继承HashMap，维护双向链表，保证插入/访问顺序，适合LRU缓存；\n   - TreeMap：基于红黑树实现，键有序，不可为null，非线程安全；\n   - ConcurrentHashMap：线程安全的HashMap，JDK8后用CAS+同步锁实现，效率高于Hashtable。\n4. Queue接口实现类：\n   - ArrayBlockingQueue：基于数组的有界阻塞队列；\n   - LinkedBlockingQueue：基于链表的无界/有界阻塞队列。', 'Java集合框架用于存储和操作数据，核心分为Collection（单列集合）和Map（双列集合）两大体系，底层基于接口和实现类的设计模式：\n### 一、体系结构\n1. Collection接口（单列集合，存储单个元素）：\n   - 子接口1：List（有序、可重复，元素有索引）；\n   - 子接口2：Set（无序、不可重复，无索引）；\n   - 子接口3：Queue（队列，先进先出，FIFO）。\n2. Map接口（双列集合，存储键值对Key-Value）：\n   - 键唯一，值可重复；\n   - 子接口：SortedMap（键有序，如TreeMap）。\n### 二、常用集合类特点\n1. List接口实现类：\n   - ArrayList：基于动态数组实现，随机访问效率高（通过索引），插入/删除（非末尾）效率低（需移动元素），非线程安全；\n   - LinkedList：基于双向链表实现，插入/删除效率高（无需移动元素），随机访问效率低（需遍历链表），非线程安全；\n   - Vector：基于数组实现，线程安全（方法加synchronized），效率低，已被ArrayList替代。\n2. Set接口实现类：\n   - HashSet：基于HashMap实现，无序、不可重复，判断重复基于hashCode()和equals()，非线程安全；\n   - LinkedHashSet：继承HashSet，维护双向链表，保证插入顺序，效率略低于HashSet；\n   - TreeSet：基于TreeMap实现，键有序（自然排序或自定义比较器），不可重复，查询效率为O(log n)。\n3. Map接口实现类：\n   - HashMap：基于数组+链表+红黑树（JDK8后），无序、键唯一，键和值均可为null，非线程安全，效率高；\n   - LinkedHashMap：继承HashMap，维护双向链表，保证插入/访问顺序，适合LRU缓存；\n   - TreeMap：基于红黑树实现，键有序，不可为null，非线程安全；\n   - ConcurrentHashMap：线程安全的HashMap，JDK8后用CAS+同步锁实现，效率高于Hashtable。\n4. Queue接口实现类：\n   - ArrayBlockingQueue：基于数组的有界阻塞队列；\n   - LinkedBlockingQueue：基于链表的无界/有界阻塞队列。', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[188]', 17);
INSERT INTO `questions` VALUES (711, '简述Java异常处理机制的核心组成，并说明try-catch-finally的执行流程。', 'SHORT_ANSWER', 'HARD', NULL, 'Java异常处理机制用于捕获和处理程序运行时的错误（如空指针、数组越界），避免程序崩溃，核心组成和执行流程如下：\n### 一、核心组成\n1. 异常类体系：\n   - 顶层父类：Throwable（所有异常和错误的根类）；\n   - 子类1：Error（系统级错误，如OutOfMemoryError、StackOverflowError，JVM抛出，无需处理）；\n   - 子类2：Exception（程序可处理的异常）：\n     - 受检异常（Checked Exception）：编译时需显式处理，如IOException、SQLException；\n     - 未受检异常（Unchecked Exception）：运行时异常，继承自RuntimeException，如NullPointerException、ArrayIndexOutOfBoundsException，编译时无需处理。\n2. 异常处理关键字：\n   - try：包裹可能抛出异常的代码块；\n   - catch：捕获并处理try块中抛出的异常，可多个catch块（按异常范围从小到大排列）；\n   - finally：无论是否发生异常，都会执行的代码块（用于释放资源，如关闭流、连接）；\n   - throw：手动抛出异常对象（如throw new NullPointerException(\"空指针异常\")）；\n   - throws：在方法声明处声明可能抛出的异常类型（如public void test() throws IOException）。\n### 二、try-catch-finally执行流程\n1. 正常流程（无异常）：\n   - 执行try块中的代码 → 跳过catch块 → 执行finally块 → 继续执行后续代码。\n2. 异常流程（try块抛出异常，被catch捕获）：\n   - 执行try块中异常前的代码 → 抛出异常 → 匹配对应的catch块并执行 → 执行finally块 → 继续执行后续代码。\n3. 异常流程（try块抛出异常，未被catch捕获）：\n   - 执行try块中异常前的代码 → 抛出异常 → 跳过catch块 → 执行finally块 → 异常向上抛出（由调用者处理，若无人处理，程序崩溃）。\n4. 特殊情况（try/catch块中有return）：\n   - 无论try或catch块中有return，finally块都会在return前执行；\n   - 若finally块中有return，会覆盖try/catch块的return值；\n   - 示例：\n     ```java\n     public static int test() {\n         try {\n             int a = 1/0;\n             return 1;\n         } catch (Exception e) {\n             return 2; // 先执行finally，再return 2\n         } finally {\n             System.out.println(\"finally执行\");\n         }\n     }\n     // 执行结果：输出“finally执行”，返回2\n     ```', 'Java异常处理机制用于捕获和处理程序运行时的错误（如空指针、数组越界），避免程序崩溃，核心组成和执行流程如下：\n### 一、核心组成\n1. 异常类体系：\n   - 顶层父类：Throwable（所有异常和错误的根类）；\n   - 子类1：Error（系统级错误，如OutOfMemoryError、StackOverflowError，JVM抛出，无需处理）；\n   - 子类2：Exception（程序可处理的异常）：\n     - 受检异常（Checked Exception）：编译时需显式处理，如IOException、SQLException；\n     - 未受检异常（Unchecked Exception）：运行时异常，继承自RuntimeException，如NullPointerException、ArrayIndexOutOfBoundsException，编译时无需处理。\n2. 异常处理关键字：\n   - try：包裹可能抛出异常的代码块；\n   - catch：捕获并处理try块中抛出的异常，可多个catch块（按异常范围从小到大排列）；\n   - finally：无论是否发生异常，都会执行的代码块（用于释放资源，如关闭流、连接）；\n   - throw：手动抛出异常对象（如throw new NullPointerException(\"空指针异常\")', 1, 1, '2025-10-31 17:29:39', '2025-10-31 17:29:39', '[186]', 17);
INSERT INTO `questions` VALUES (712, 'MySQL中，以下哪个语句用于创建数据库？', 'SINGLE_CHOICE', 'EASY', '[\"CREATE TABLE\", \"CREATE DATABASE\", \"ALTER DATABASE\", \"INSERT DATABASE\"]', 'B', 'CREATE DATABASE用于创建数据库；CREATE TABLE用于创建表；ALTER DATABASE用于修改数据库属性；MySQL中无INSERT DATABASE语句。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[202]', 18);
INSERT INTO `questions` VALUES (713, '以下哪种数据类型适合存储变长字符串，且能自动截取超出长度的内容？', 'SINGLE_CHOICE', 'EASY', '[\"CHAR\", \"TEXT\", \"VARCHAR\", \"BLOB\"]', 'C', 'VARCHAR是变长字符串类型，指定长度后，实际存储按内容长度分配，超出指定长度时会自动截取（需注意SQL模式是否严格）；CHAR是定长字符串；TEXT用于长文本，不适合频繁修改；BLOB用于二进制数据。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[203]', 18);
INSERT INTO `questions` VALUES (714, 'MySQL中，主键（PRIMARY KEY）的特点不包括？', 'SINGLE_CHOICE', 'MEDIUM', '[\"唯一标识表中的记录\", \"允许为NULL值\", \"一个表只能有一个主键\", \"自动创建唯一索引\"]', 'B', '主键的核心特点是唯一且非空（不允许为NULL），用于唯一标识记录；一个表只能定义一个主键，主键字段会自动创建唯一索引以提升查询效率。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[204]', 18);
INSERT INTO `questions` VALUES (715, '以下哪个语句用于从表中删除所有记录，但保留表结构？', 'SINGLE_CHOICE', 'EASY', '[\"DELETE\", \"DROP\", \"TRUNCATE\", \"REMOVE\"]', 'C', 'TRUNCATE用于删除表中所有记录，保留表结构，属于DDL操作，速度快且不记录日志；DELETE是DML操作，逐行删除并记录日志；DROP用于删除表结构；MySQL中无REMOVE语句。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[205]', 18);
INSERT INTO `questions` VALUES (716, 'MySQL中，以下哪种索引类型主要用于全文搜索？', 'SINGLE_CHOICE', 'MEDIUM', '[\"B+树索引\", \"哈希索引\", \"全文索引\", \"空间索引\"]', 'C', '全文索引（FULLTEXT）用于对长文本字段进行全文搜索，支持关键词匹配；B+树索引是最常用的索引类型，适用于范围查询；哈希索引适用于精确匹配；空间索引用于地理数据类型。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[206]', 18);
INSERT INTO `questions` VALUES (717, '事务的ACID特性中，“A”代表的是？', 'SINGLE_CHOICE', 'EASY', '[\"原子性（Atomicity）\", \"一致性（Consistency）\", \"隔离性（Isolation）\", \"持久性（Durability）\"]', 'A', '事务ACID特性：A（Atomicity，原子性）指事务要么全部执行，要么全部不执行；C（Consistency）指事务执行前后数据保持一致；I（Isolation）指事务间相互隔离；D（Durability）指事务提交后数据永久保存。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[207]', 18);
INSERT INTO `questions` VALUES (718, '以下哪个语句用于查看当前数据库中的所有表？', 'SINGLE_CHOICE', 'EASY', '[\"SHOW DATABASES\", \"SHOW TABLES\", \"DESCRIBE TABLES\", \"LIST TABLES\"]', 'B', 'SHOW TABLES用于显示当前数据库中的所有表；SHOW DATABASES用于显示所有数据库；DESCRIBE用于查看表结构；MySQL中无LIST TABLES语句。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[202]', 18);
INSERT INTO `questions` VALUES (719, 'MySQL中，默认的事务隔离级别是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"读未提交（READ UNCOMMITTED）\", \"读已提交（READ COMMITTED）\", \"可重复读（REPEATABLE READ）\", \"串行化（SERIALIZABLE）\"]', 'C', 'MySQL默认事务隔离级别为可重复读（REPEATABLE READ），可通过`SELECT @@tx_isolation;`查看；InnoDB存储引擎支持所有四种隔离级别。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[208]', 18);
INSERT INTO `questions` VALUES (720, '以下哪个操作会导致索引失效？', 'SINGLE_CHOICE', 'MEDIUM', '[\"使用LIKE \'abc%\'查询\", \"对索引字段使用函数（如SUBSTR(name, 1, 3)）\", \"使用索引字段作为查询条件\", \"联合索引中使用最左前缀匹配\"]', 'B', '对索引字段使用函数会导致MySQL无法使用索引，需全表扫描；LIKE \'abc%\'（前缀匹配）可使用索引；索引字段直接作为查询条件或联合索引满足最左前缀原则时，索引有效。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[209]', 18);
INSERT INTO `questions` VALUES (721, '以下哪种存储引擎不支持事务？', 'SINGLE_CHOICE', 'EASY', '[\"InnoDB\", \"MyISAM\", \"BDB\", \"NDB Cluster\"]', 'B', 'MyISAM是MySQL早期默认存储引擎，不支持事务和行级锁，支持表级锁；InnoDB支持事务、行级锁和外键；BDB和NDB Cluster也支持事务。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[210]', 18);
INSERT INTO `questions` VALUES (722, '用于在查询结果中去除重复记录的关键字是？', 'SINGLE_CHOICE', 'EASY', '[\"DISTINCT\", \"UNIQUE\", \"DIFFERENT\", \"DISTINCTROW\"]', 'A', 'DISTINCT用于在SELECT语句中去除重复记录，如`SELECT DISTINCT name FROM user;`；UNIQUE是约束关键字，用于定义唯一索引；MySQL中无DIFFERENT和DISTINCTROW关键字（DISTINCTROW是SQLite的语法）。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[211]', 18);
INSERT INTO `questions` VALUES (723, 'MySQL中，以下哪个语句用于修改表中已有的数据？', 'SINGLE_CHOICE', 'EASY', '[\"INSERT\", \"UPDATE\", \"ALTER\", \"MODIFY\"]', 'B', 'UPDATE用于修改表中现有记录，语法为`UPDATE 表名 SET 字段=值 WHERE 条件;`；INSERT用于插入新记录；ALTER用于修改表结构；MODIFY是ALTER语句的子句（如ALTER TABLE ... MODIFY ...）。', 0, 6, '2025-11-04 14:24:09', '2025-11-04 14:24:09', '[205]', 18);
INSERT INTO `questions` VALUES (724, '联合索引（a, b, c）中，以下哪个查询无法使用该索引？', 'SINGLE_CHOICE', 'MEDIUM', '[\"WHERE a = 1\", \"WHERE a = 1 AND b = 2\", \"WHERE b = 2 AND a = 1\", \"WHERE b = 2 AND c = 3\"]', 'D', '联合索引遵循“最左前缀原则”，必须从第一个字段开始匹配；D选项未使用索引第一个字段a，无法使用联合索引；C选项中a和b的顺序不影响（MySQL会优化条件顺序），仍可使用索引。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[212]', 18);
INSERT INTO `questions` VALUES (725, '以下哪个函数用于计算表中记录的数量？', 'SINGLE_CHOICE', 'EASY', '[\"COUNT()\", \"SUM()\", \"AVG()\", \"MAX()\"]', 'A', 'COUNT()用于统计记录或非NULL值的数量，如`COUNT(*)`统计所有记录，`COUNT(id)`统计id非NULL的记录；SUM()用于求和；AVG()用于求平均值；MAX()用于求最大值。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[213]', 18);
INSERT INTO `questions` VALUES (726, 'MySQL中，外键（FOREIGN KEY）的主要作用是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"提高查询效率\", \"保证数据的参照完整性\", \"实现数据的自动排序\", \"减少数据冗余\"]', 'B', '外键用于关联两个表，保证从表的外键值必须在主表的主键中存在（或为NULL），从而维护数据的参照完整性；索引用于提高查询效率；外键不直接减少冗余或实现排序。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[204]', 18);
INSERT INTO `questions` VALUES (727, '以下哪种锁是MySQL InnoDB引擎支持的行级锁？', 'SINGLE_CHOICE', 'HARD', '[\"表锁\", \"意向锁\", \"共享锁（S锁）\", \"元数据锁（MDL）\"]', 'C', 'InnoDB支持行级锁，包括共享锁（S锁，读锁）和排他锁（X锁，写锁）；表锁、意向锁（表级）、元数据锁（表级）均为表级锁；行级锁粒度更细，并发性能更高。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[214]', 18);
INSERT INTO `questions` VALUES (728, '用于将多个SELECT语句的结果合并为一个结果集的关键字是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"JOIN\", \"UNION\", \"MERGE\", \"COMBINE\"]', 'B', 'UNION用于合并多个SELECT的结果集，要求列数和数据类型兼容，默认去重；UNION ALL保留重复记录；JOIN用于表连接；MySQL中无MERGE和COMBINE关键字。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[211]', 18);
INSERT INTO `questions` VALUES (729, 'MySQL中，以下哪个配置参数用于设置InnoDB缓冲池大小？', 'SINGLE_CHOICE', 'HARD', '[\"innodb_log_buffer_size\", \"innodb_buffer_pool_size\", \"key_buffer_size\", \"query_cache_size\"]', 'B', 'innodb_buffer_pool_size用于设置InnoDB缓冲池大小（缓存数据和索引，是最重要的性能参数之一）；innodb_log_buffer_size是日志缓冲区大小；key_buffer_size是MyISAM索引缓冲区大小；query_cache_size是查询缓存大小（MySQL 8.0已移除）。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[215]', 18);
INSERT INTO `questions` VALUES (730, '以下哪个语句用于创建视图（View）？', 'SINGLE_CHOICE', 'MEDIUM', '[\"CREATE VIEW\", \"CREATE TABLE AS\", \"CREATE INDEX\", \"CREATE PROCEDURE\"]', 'A', 'CREATE VIEW用于创建视图（虚拟表，基于SELECT语句的结果集）；CREATE TABLE AS用于创建表并插入数据；CREATE INDEX用于创建索引；CREATE PROCEDURE用于创建存储过程。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[216]', 18);
INSERT INTO `questions` VALUES (731, 'MySQL中，“慢查询日志”的主要作用是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"记录所有SQL语句的执行结果\", \"记录执行时间超过阈值的SQL语句\", \"记录数据库启动和关闭日志\", \"记录用户登录和权限变更日志\"]', 'B', '慢查询日志用于记录执行时间超过`long_query_time`（默认10秒）的SQL语句，帮助定位性能瓶颈；其他选项分别对应通用日志、错误日志、审计日志的功能。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[217]', 18);
INSERT INTO `questions` VALUES (732, '以下哪种数据类型适合存储日期和时间（精确到秒）？', 'SINGLE_CHOICE', 'EASY', '[\"DATE\", \"TIME\", \"DATETIME\", \"YEAR\"]', 'C', 'DATETIME用于存储日期和时间（格式YYYY-MM-DD HH:MM:SS），范围1000-01-01 00:00:00到9999-12-31 23:59:59；DATE仅存日期；TIME仅存时间；YEAR仅存年份。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[203]', 18);
INSERT INTO `questions` VALUES (733, 'MySQL中，以下哪个语句用于删除表中的索引？', 'SINGLE_CHOICE', 'MEDIUM', '[\"DROP INDEX\", \"DELETE INDEX\", \"REMOVE INDEX\", \"ALTER INDEX\"]', 'A', '删除索引的语法为`DROP INDEX 索引名 ON 表名;`或`ALTER TABLE 表名 DROP INDEX 索引名;`；MySQL中无DELETE INDEX和REMOVE INDEX语句；ALTER INDEX用于修改索引属性（较少使用）。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[218]', 18);
INSERT INTO `questions` VALUES (734, '事务隔离级别中，可能导致“幻读”的级别是？', 'MULTIPLE_CHOICE', 'HARD', '[\"读未提交\", \"读已提交\", \"可重复读\", \"串行化\"]', 'A,B,C', '幻读指事务中多次查询时，其他事务插入新记录导致结果集行数变化；读未提交和读已提交可能出现幻读；MySQL的可重复读通过MVCC（多版本并发控制）避免了幻读；串行化完全禁止并发，无幻读。', 0, 6, '2025-11-04 14:24:10', '2025-11-05 14:15:07', '[208]', 18);
INSERT INTO `questions` VALUES (735, '以下哪个操作属于DDL（数据定义语言）？', 'SINGLE_CHOICE', 'EASY', '[\"INSERT\", \"UPDATE\", \"CREATE TABLE\", \"SELECT\"]', 'C', 'DDL用于定义数据库结构，包括CREATE（创建）、ALTER（修改）、DROP（删除）等；INSERT、UPDATE属于DML（数据操纵语言）；SELECT属于DQL（数据查询语言）。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[219]', 18);
INSERT INTO `questions` VALUES (736, 'MySQL中，以下哪个存储引擎支持聚簇索引？', 'SINGLE_CHOICE', 'MEDIUM', '[\"MyISAM\", \"InnoDB\", \"Memory\", \"CSV\"]', 'B', 'InnoDB的主键索引是聚簇索引（数据与索引存储在一起），辅助索引存储主键值；MyISAM的索引和数据分离（非聚簇索引）；Memory和CSV均不支持聚簇索引。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[210]', 18);
INSERT INTO `questions` VALUES (737, '用于限制查询结果返回行数的关键字是？', 'SINGLE_CHOICE', 'EASY', '[\"LIMIT\", \"OFFSET\", \"ROWS\", \"TOP\"]', 'A', 'MySQL中用LIMIT限制返回行数，如`SELECT * FROM user LIMIT 10;`（返回前10行）；OFFSET用于指定偏移量（如LIMIT 10 OFFSET 5）；TOP是SQL Server的语法。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[211]', 18);
INSERT INTO `questions` VALUES (738, '以下哪个函数用于在字符串中替换指定内容？', 'SINGLE_CHOICE', 'MEDIUM', '[\"REPLACE()\", \"SUBSTRING()\", \"CONCAT()\", \"TRIM()\"]', 'A', 'REPLACE(str, old, new)用于将字符串str中的old替换为new；SUBSTRING()用于截取子串；CONCAT()用于拼接字符串；TRIM()用于去除首尾空格或指定字符。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[220]', 18);
INSERT INTO `questions` VALUES (739, 'MySQL中，以下哪种情况会导致死锁？', 'SINGLE_CHOICE', 'HARD', '[\"一个事务持有表锁，另一个事务申请行锁\", \"两个事务按相同顺序申请锁\", \"两个事务按相反顺序申请锁，且都不释放已持有锁\", \"事务执行时间过长\"]', 'C', '死锁指两个或多个事务相互等待对方释放锁而陷入无限等待；按相反顺序申请锁（如事务1持有A锁申请B锁，事务2持有B锁申请A锁）是死锁的典型场景；A、B、D不会导致死锁。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[214]', 18);
INSERT INTO `questions` VALUES (740, '以下哪个语句用于查看表的结构？', 'SINGLE_CHOICE', 'EASY', '[\"SHOW TABLE\", \"DESCRIBE\", \"LIST COLUMNS\", \"VIEW STRUCTURE\"]', 'B', 'DESCRIBE 表名（或简写为DESC 表名）用于查看表的字段、类型、约束等结构信息；SHOW TABLE用于显示表列表；MySQL中无LIST COLUMNS和VIEW STRUCTURE语句。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[221]', 18);
INSERT INTO `questions` VALUES (741, 'MySQL中，二进制日志（binlog）的主要作用是？', 'SINGLE_CHOICE', 'MEDIUM', '[\"记录数据库启动和错误信息\", \"记录所有数据修改操作，用于主从复制和数据恢复\", \"记录慢查询SQL语句\", \"记录用户连接信息\"]', 'B', '二进制日志（binlog）记录所有DML和DDL操作，是主从复制的核心（从库通过读取主库binlog同步数据），也可用于时间点恢复；A是错误日志功能；C是慢查询日志功能；D是通用日志功能。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[222]', 18);
INSERT INTO `questions` VALUES (742, '以下属于MySQL常用存储引擎的有？', 'MULTIPLE_CHOICE', 'EASY', '[\"InnoDB\", \"MyISAM\", \"MongoDB\", \"Memory\", \"Redis\"]', 'A,B,D', 'InnoDB、MyISAM、Memory是MySQL的内置存储引擎；MongoDB和Redis是独立的NoSQL数据库，不属于MySQL存储引擎。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[210]', 18);
INSERT INTO `questions` VALUES (743, '事务隔离级别中，能解决“脏读”问题的级别有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"读未提交（READ UNCOMMITTED）\", \"读已提交（READ COMMITTED）\", \"可重复读（REPEATABLE READ）\", \"串行化（SERIALIZABLE）\", \"以上都不能\"]', 'B,C,D', '脏读指读取到未提交的事务数据；读已提交、可重复读、串行化级别通过隔离机制避免脏读；读未提交允许脏读。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[208]', 18);
INSERT INTO `questions` VALUES (744, '以下哪些索引类型是MySQL支持的？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"B+树索引\", \"哈希索引\", \"全文索引\", \"空间索引\", \"位图索引\"]', 'A,B,C,D', 'MySQL支持B+树索引（默认）、哈希索引（Memory引擎）、全文索引（InnoDB/MyISAM）、空间索引（用于地理数据）；位图索引主要用于Oracle等数据库，MySQL不支持。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[206]', 18);
INSERT INTO `questions` VALUES (745, '以下哪些操作会触发隐式事务提交？', 'MULTIPLE_CHOICE', 'HARD', '[\"CREATE TABLE\", \"ALTER TABLE\", \"INSERT\", \"DROP DATABASE\", \"SELECT\"]', 'A,B,D', 'DDL操作（如CREATE、ALTER、DROP）会隐式提交当前事务；INSERT是DML操作，需显式COMMIT；SELECT不影响事务。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[207]', 18);
INSERT INTO `questions` VALUES (746, '以下关于MySQL索引的说法，正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"索引可以提高查询效率，但会降低插入、更新、删除的效率\", \"一个表可以创建多个索引\", \"主键索引一定是唯一索引\", \"唯一索引允许字段值为NULL（但最多一个NULL）\", \"联合索引中，只要包含索引字段就一定能使用索引\"]', 'A,B,C,D', '索引通过增加写操作的开销（维护索引结构）换取读操作效率提升；一个表可创建多个索引（但不宜过多）；主键索引要求唯一且非空，故一定是唯一索引；唯一索引允许NULL（但NULL不重复）；联合索引需满足最左前缀原则才能使用，E错误。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[206]', 18);
INSERT INTO `questions` VALUES (747, 'MySQL中，以下哪些函数属于聚合函数？', 'MULTIPLE_CHOICE', 'EASY', '[\"COUNT()\", \"SUM()\", \"AVG()\", \"MAX()\", \"CONCAT()\"]', 'A,B,C,D', 'COUNT（计数）、SUM（求和）、AVG（平均值）、MAX（最大值）均为聚合函数，用于对一组数据进行计算并返回单一结果；CONCAT是字符串拼接函数，不属于聚合函数。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[213]', 18);
INSERT INTO `questions` VALUES (748, '以下关于InnoDB和MyISAM的区别，正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"InnoDB支持事务，MyISAM不支持\", \"InnoDB支持行级锁，MyISAM支持表级锁\", \"InnoDB支持外键，MyISAM不支持\", \"InnoDB表空间占用更大，MyISAM更节省空间\", \"InnoDB适合读多写少场景，MyISAM适合写多读少场景\"]', 'A,B,C,D', 'InnoDB支持事务、行级锁、外键，适合写多读多场景（并发高），但表空间占用大；MyISAM不支持事务和外键，用表级锁，适合读多写少场景（如博客、新闻），空间占用小；E选项描述反了。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[210]', 18);
INSERT INTO `questions` VALUES (749, '以下哪些语句可以用于MySQL的备份与恢复？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"mysqldump\", \"LOAD DATA INFILE\", \"BACKUP DATABASE\", \"RESTORE DATABASE\", \"mysqlbinlog\"]', 'A,B,E', 'mysqldump是MySQL官方备份工具（逻辑备份）；LOAD DATA INFILE用于导入数据；mysqlbinlog用于解析binlog进行时间点恢复；BACKUP/RESTORE DATABASE是SQL Server的语法，MySQL不支持。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[223]', 18);
INSERT INTO `questions` VALUES (750, 'MySQL中，以下哪些是常见的优化SQL语句的方法？', 'MULTIPLE_CHOICE', 'HARD', '[\"避免使用SELECT *，只查询需要的字段\", \"对查询条件字段建立索引\", \"避免在WHERE子句中使用函数或表达式\", \"大表分页查询使用LIMIT配合索引\", \"多表连接时，小表作为驱动表\"]', 'A,B,C,D,E', '优化SQL的核心原则包括减少数据传输（A）、利用索引（B、C、D）、优化连接效率（E）；这些方法均可有效提升查询性能。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[217]', 18);
INSERT INTO `questions` VALUES (751, '以下关于MySQL主从复制的说法，正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"主从复制基于二进制日志（binlog）实现\", \"主库执行的SQL会记录到binlog，从库通过IO线程获取并执行\", \"主从复制可以实现读写分离（主库写，从库读）\", \"主从复制一定能保证数据实时一致性\", \"从库可以有多个，形成一主多从架构\"]', 'A,C,E', '主从复制中，主库写binlog，从库IO线程拉取binlog到relay log，SQL线程执行relay log（B错误）；主从复制存在延迟，不能保证实时一致（D错误）；A、C、E描述正确。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[224]', 18);
INSERT INTO `questions` VALUES (752, 'MySQL中，以下哪些约束可以保证字段值的唯一性？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"PRIMARY KEY\", \"UNIQUE\", \"FOREIGN KEY\", \"NOT NULL\", \"CHECK\"]', 'A,B', 'PRIMARY KEY（主键）和UNIQUE（唯一约束）均能保证字段值唯一；PRIMARY KEY还要求非空；FOREIGN KEY是参照约束；NOT NULL仅限制非空；CHECK用于检查字段值是否满足条件（MySQL 8.0后支持）。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[204]', 18);
INSERT INTO `questions` VALUES (753, '以下关于MySQL视图的说法，正确的有？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"视图是虚拟表，数据不实际存储\", \"视图可以简化复杂查询\", \"所有视图都可以执行INSERT/UPDATE/DELETE操作\", \"视图可以隐藏敏感数据（如只显示部分字段）\", \"视图的查询性能一定优于直接查询表\"]', 'A,B,D', '视图基于SELECT语句创建，不存储数据（A正确）；可封装复杂逻辑（B正确）、限制数据访问（D正确）；不可更新视图（如含聚合函数、DISTINCT的视图）无法执行写操作（C错误）；视图性能不一定优于表查询，复杂视图可能效率更低（E错误）。', 0, 6, '2025-11-04 14:24:10', '2025-11-04 14:24:10', '[216]', 18);
INSERT INTO `questions` VALUES (754, 'MySQL中，以下哪些日志类型是默认开启的？', 'MULTIPLE_CHOICE', 'MEDIUM', '[\"错误日志（error log）\", \"二进制日志（binlog）\", \"慢查询日志（slow query log）\", \"通用日志（general log）\", \"中继日志（relay log）\"]', 'A', 'MySQL默认只开启错误日志；binlog、慢查询日志、通用日志默认关闭，需手动配置开启；中继日志仅从库在主从复制时自动生成，非默认开启的常规日志。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[222]', 18);
INSERT INTO `questions` VALUES (755, '以下关于MySQL锁机制的说法，正确的有？', 'MULTIPLE_CHOICE', 'HARD', '[\"表级锁粒度大，并发性能低；行级锁粒度小，并发性能高\", \"InnoDB的行锁是基于索引实现的，无索引时会升级为表锁\", \"共享锁（S锁）允许并发读，不允许写\", \"排他锁（X锁）不允许其他事务读或写\", \"意向锁用于协调表锁和行锁的关系\"]', 'A,B,C,D,E', '锁粒度与并发性能成反比（A正确）；InnoDB行锁依赖索引，无索引时无法定位行，故升级为表锁（B正确）；S锁允许多个事务读，X锁独占（C、D正确）；意向锁（如IS、IX）表示事务准备加行锁，避免表锁和行锁冲突（E正确）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[214]', 18);
INSERT INTO `questions` VALUES (756, '以下哪些数据类型属于MySQL的数值类型？', 'MULTIPLE_CHOICE', 'EASY', '[\"INT\", \"VARCHAR\", \"FLOAT\", \"DECIMAL\", \"DATE\"]', 'A,C,D', 'INT（整数）、FLOAT（单精度浮点）、DECIMAL（高精度小数）均为数值类型；VARCHAR是字符串类型；DATE是日期类型。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[203]', 18);
INSERT INTO `questions` VALUES (757, 'MySQL是一种关系型数据库管理系统。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'MySQL基于关系模型（表、行、列），支持SQL语言和ACID事务，属于典型的关系型数据库管理系统（RDBMS）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[225]', 18);
INSERT INTO `questions` VALUES (758, 'InnoDB存储引擎支持表级锁，不支持行级锁。', 'TRUE_FALSE', 'EASY', NULL, 'false', 'InnoDB是MySQL中唯一支持行级锁的存储引擎，同时也支持表级锁（如意向锁、元数据锁）；MyISAM仅支持表级锁。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[210]', 18);
INSERT INTO `questions` VALUES (759, '主键可以由多个字段组合而成（联合主键）。', 'TRUE_FALSE', 'MEDIUM', NULL, 'true', '联合主键指将多个字段组合作为主键，确保组合值唯一且非空，适用于单一字段无法唯一标识记录的场景（如订单详情表的订单ID+商品ID）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[204]', 18);
INSERT INTO `questions` VALUES (760, 'MySQL的查询缓存（Query Cache）可以显著提升所有查询的性能。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '查询缓存缓存SQL语句及其结果，仅适用于不常变更的静态数据；对于频繁更新的表，缓存失效频繁，反而增加开销；MySQL 8.0已移除查询缓存功能。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[217]', 18);
INSERT INTO `questions` VALUES (761, '事务的持久性（Durability）指事务一旦提交，即使数据库崩溃，数据也不会丢失。', 'TRUE_FALSE', 'EASY', NULL, 'true', '持久性是ACID特性之一，通过日志（如InnoDB的redo log）保证，事务提交后数据会被永久写入磁盘，即使发生故障也可恢复。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[207]', 18);
INSERT INTO `questions` VALUES (762, '索引越多越好，创建所有字段的索引可以最大化查询效率。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '索引会增加写操作（INSERT/UPDATE/DELETE）的开销（需维护索引结构），过多索引会导致表体积增大、性能下降；应仅为常用查询条件创建索引。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[206]', 18);
INSERT INTO `questions` VALUES (763, 'MySQL中，NULL值表示空字符串（\"\"）。', 'TRUE_FALSE', 'EASY', NULL, 'false', 'NULL表示“未知”或“不存在”，与空字符串（\"\"）不同：NULL不等于任何值（包括自身），需用IS NULL/IS NOT NULL判断；空字符串是有效值，可用=判断。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[226]', 18);
INSERT INTO `questions` VALUES (764, '主从复制中，主库和从库的数据库版本必须完全一致。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '主从复制允许从库版本高于主库（如主库5.7，从库8.0），但不允许从库版本低于主库（可能存在兼容性问题），无需完全一致。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[224]', 18);
INSERT INTO `questions` VALUES (765, 'ALTER TABLE语句用于修改表中的数据记录。', 'TRUE_FALSE', 'EASY', NULL, 'false', 'ALTER TABLE属于DDL语句，用于修改表结构（如添加字段、修改类型）；修改表中数据记录需用UPDATE语句（DML）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[219]', 18);
INSERT INTO `questions` VALUES (766, 'MySQL的InnoDB引擎使用MVCC（多版本并发控制）实现高并发。', 'TRUE_FALSE', 'HARD', NULL, 'true', 'MVCC是InnoDB实现隔离级别的核心机制，通过为每行数据创建多个版本，允许读写不冲突（读不加锁），大幅提升并发性能。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[227]', 18);
INSERT INTO `questions` VALUES (767, '联合索引的生效顺序必须与创建顺序完全一致。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '联合索引遵循“最左前缀原则”，只要查询条件包含索引的最左字段即可部分生效（如索引(a,b,c)，查询a=1或a=1 AND b=2均生效），条件顺序不影响（MySQL会优化）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[212]', 18);
INSERT INTO `questions` VALUES (768, '存储过程可以包含条件判断、循环等逻辑，类似于编程语言的函数。', 'TRUE_FALSE', 'MEDIUM', NULL, 'true', '存储过程是预编译的SQL集合，支持变量、条件分支（IF-ELSE）、循环（WHILE）等逻辑，可封装复杂业务，减少网络传输。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[228]', 18);
INSERT INTO `questions` VALUES (769, 'MySQL的慢查询日志只会记录SELECT语句，不会记录UPDATE/DELETE语句。', 'TRUE_FALSE', 'MEDIUM', NULL, 'false', '慢查询日志记录所有执行时间超过阈值的SQL语句，包括SELECT、UPDATE、DELETE、INSERT等，只要执行时间达标均会被记录。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[222]', 18);
INSERT INTO `questions` VALUES (770, '外键约束会降低表的插入和更新性能。', 'TRUE_FALSE', 'MEDIUM', NULL, 'true', '外键约束会导致插入/更新时额外检查参照关系（如从表外键是否在主表存在），增加性能开销；高并发场景有时会移除外键，通过应用层保证数据一致性。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[204]', 18);
INSERT INTO `questions` VALUES (771, 'MySQL中，使用EXPLAIN语句可以分析SQL的执行计划。', 'TRUE_FALSE', 'EASY', NULL, 'true', 'EXPLAIN语句用于查看SQL的执行计划，包括是否使用索引、表连接方式、扫描行数等，是优化SQL的核心工具。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[217]', 18);
INSERT INTO `questions` VALUES (772, 'MySQL中，______语句用于向表中插入新记录。', 'FILL_BLANK', 'EASY', NULL, 'INSERT', 'INSERT语句的基本语法为`INSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2);`，用于插入一条或多条新记录。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[205]', 18);
INSERT INTO `questions` VALUES (773, '事务的四大特性包括原子性、一致性、隔离性和______。', 'FILL_BLANK', 'EASY', NULL, '持久性', '事务ACID特性：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性），持久性指事务提交后数据永久保存。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[207]', 18);
INSERT INTO `questions` VALUES (774, 'MySQL中，______存储引擎是默认的事务型存储引擎。', 'FILL_BLANK', 'EASY', NULL, 'InnoDB', '自MySQL 5.5起，InnoDB成为默认存储引擎，支持事务、行级锁、外键等特性，适合大多数业务场景。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[210]', 18);
INSERT INTO `questions` VALUES (775, '用于在两个表之间建立连接查询的关键字是______。', 'FILL_BLANK', 'MEDIUM', NULL, 'JOIN', 'JOIN用于多表连接，包括INNER JOIN（内连接）、LEFT JOIN（左连接）、RIGHT JOIN（右连接）等，通过关联字段合并多个表的数据。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[211]', 18);
INSERT INTO `questions` VALUES (776, 'MySQL中，______命令用于导出数据库备份（逻辑备份）。', 'FILL_BLANK', 'MEDIUM', NULL, 'mysqldump', 'mysqldump是MySQL官方的逻辑备份工具，语法为`mysqldump -u 用户名 -p 数据库名 &gt; 备份文件.sql`，可导出表结构和数据。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[223]', 18);
INSERT INTO `questions` VALUES (777, '索引的______原则指联合索引中，查询条件需包含索引的最左侧字段才能使用索引。', 'FILL_BLANK', 'MEDIUM', NULL, '最左前缀', '最左前缀原则是联合索引的核心规则，如索引(a,b,c)，仅当查询条件包含a时，索引才可能生效；包含a和b时，索引部分生效；不包含a时，索引完全失效。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[212]', 18);
INSERT INTO `questions` VALUES (778, 'MySQL中，______语句用于删除表结构及所有数据。', 'FILL_BLANK', 'EASY', NULL, 'DROP TABLE', 'DROP TABLE 表名用于彻底删除表（包括结构和数据），操作不可逆；删除数据但保留结构用TRUNCATE或DELETE。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[221]', 18);
INSERT INTO `questions` VALUES (779, 'InnoDB的______日志用于保证事务的持久性，记录已提交的事务数据。', 'FILL_BLANK', 'HARD', NULL, 'redo', 'redo log（重做日志）是InnoDB的核心日志，记录事务对数据的修改，确保事务提交后即使发生崩溃，重启后也能通过redo log恢复数据，保证持久性。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[222]', 18);
INSERT INTO `questions` VALUES (780, '用于计算两个日期之间差值的函数是______。', 'FILL_BLANK', 'MEDIUM', NULL, 'DATEDIFF', 'DATEDIFF(date1, date2)返回date1与date2之间的天数差（date1 - date2），如`SELECT DATEDIFF(\'2023-10-01\', \'2023-09-01\');`返回30。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[229]', 18);
INSERT INTO `questions` VALUES (781, 'MySQL中，______隔离级别可以避免脏读、不可重复读和幻读。', 'FILL_BLANK', 'HARD', NULL, '串行化', '串行化（SERIALIZABLE）是最高隔离级别，通过强制事务串行执行（加表锁），避免所有并发问题（脏读、不可重复读、幻读），但并发性能最低。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[208]', 18);
INSERT INTO `questions` VALUES (782, '简述MySQL中InnoDB和MyISAM的主要区别。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'InnoDB和MyISAM的核心区别如下：\n1. 事务支持：InnoDB支持事务（ACID特性），MyISAM不支持；\n2. 锁机制：InnoDB支持行级锁和表级锁，MyISAM仅支持表级锁；\n3. 外键支持：InnoDB支持外键约束，MyISAM不支持；\n4. 索引类型：InnoDB的主键是聚簇索引（数据与索引存储在一起），MyISAM的索引与数据分离（非聚簇索引）；\n5. 崩溃恢复：InnoDB通过redo log支持崩溃后的数据恢复，MyISAM恢复困难，可能丢失数据；\n6. 适用场景：InnoDB适合写操作频繁、需要事务和高并发的场景（如电商订单）；MyISAM适合读多写少、无需事务的场景（如博客文章）。', '二者的核心差异体现在事务和锁机制上，这直接决定了适用场景：InnoDB通过行级锁和事务支持高并发写入，而MyISAM因表级锁限制，更适合读密集场景。实际应用中，InnoDB是绝大多数业务的首选。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[210]', 18);
INSERT INTO `questions` VALUES (783, '详细说明MySQL索引的作用及常见失效场景。', 'SHORT_ANSWER', 'HARD', NULL, 'MySQL索引的作用及失效场景如下：\n一、作用：\n1. 提高查询效率：通过索引快速定位数据，减少磁盘IO（类似书籍目录）；\n2. 加速排序和分组：索引本身有序，可避免额外排序操作；\n3. 强制数据唯一性：唯一索引和主键索引保证字段值不重复。\n二、常见失效场景：\n1. 对索引字段使用函数或表达式（如`WHERE SUBSTR(name,1,3) = \'abc\'`）；\n2. 索引字段参与运算（如`WHERE id + 1 = 10`）；\n3. 使用`NOT IN`、`!=`、`&lt;&gt;`等操作符（可能导致全表扫描）；\n4. 字符串不加引号（如`WHERE name = 123`，导致类型转换）；\n5. LIKE以通配符开头（如`WHERE name LIKE \'%abc\'`）；\n6. 联合索引不满足最左前缀原则（如索引(a,b)，查询`WHERE b = 1`）；\n7. 索引字段为NULL（需用IS NULL，= NULL会失效）；\n8. OR条件中存在非索引字段（如`WHERE a = 1 OR b = 2`，b无索引则a的索引失效）。', '索引失效的核心原因是MySQL无法利用索引结构快速定位数据，被迫进行全表扫描。实际优化中，需通过EXPLAIN分析执行计划，避免上述场景，同时注意索引的合理性（不滥用）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[206]', 18);
INSERT INTO `questions` VALUES (784, '简述MySQL事务的ACID特性及实现原理。', 'SHORT_ANSWER', 'HARD', NULL, 'MySQL事务的ACID特性及实现原理如下：\n1. 原子性（Atomicity）：\n   - 特性：事务中所有操作要么全执行，要么全不执行（如转账时扣钱和加钱必须同时成功或失败）；\n   - 实现：通过undo log（回滚日志），记录事务修改前的状态，失败时通过undo log回滚到初始状态。\n2. 一致性（Consistency）：\n   - 特性：事务执行前后，数据从一个一致状态变为另一个一致状态（如转账总金额不变）；\n   - 实现：由业务逻辑（如代码约束）和数据库约束（如主键、外键、CHECK）共同保证。\n3. 隔离性（Isolation）：\n   - 特性：多个事务并发执行时，彼此不干扰，结果等同于串行执行；\n   - 实现：通过锁机制（行锁、表锁）和MVCC（多版本并发控制），避免脏读、不可重复读、幻读。\n4. 持久性（Durability）：\n   - 特性：事务提交后，数据永久保存，即使数据库崩溃也不丢失；\n   - 实现：通过redo log（重做日志），事务提交时将修改写入redo log，崩溃后可通过redo log恢复数据。', 'ACID特性中，原子性、隔离性、持久性由数据库实现，一致性需数据库和应用共同保障。InnoDB通过undo log、redo log、锁和MVCC四大机制，完整支持ACID特性。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[207]', 18);
INSERT INTO `questions` VALUES (785, '简述MySQL主从复制的原理及主要步骤。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'MySQL主从复制是指主库的数据变更自动同步到从库，用于读写分离、容灾备份，原理及步骤如下：\n1. 核心原理：基于二进制日志（binlog）的异步复制，主库记录数据变更到binlog，从库获取并执行这些变更。\n2. 主要步骤：\n   - 步骤1：主库开启binlog，当执行DML/DDL操作时，将变更记录到binlog（按事件格式）；\n   - 步骤2：从库启动两个线程：IO线程和SQL线程；\n     - IO线程：连接主库，请求获取binlog，将主库发送的binlog写入从库的中继日志（relay log）；\n     - SQL线程：读取中继日志，解析并执行其中的SQL语句，同步数据到从库；\n   - 步骤3：从库通过上述过程，保持与主库数据一致（存在一定延迟）。\n3. 架构：支持一主多从（主库写，多从库读）、级联复制（从库作为其他从库的主库）等。', '主从复制的核心是“binlog传递+重放”，异步机制意味着主库不等待从库完成同步，可能存在数据延迟。实际应用中，可通过半同步复制（主库等待至少一个从库确认）降低数据丢失风险。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[224]', 18);
INSERT INTO `questions` VALUES (786, '如何优化MySQL的查询性能？请列举至少5种方法。', 'SHORT_ANSWER', 'MEDIUM', NULL, '优化MySQL查询性能的常用方法如下：\n1. 合理创建索引：为查询条件、排序字段、分组字段创建索引，避免冗余索引；联合索引遵循最左前缀原则；\n2. 优化SQL语句：\n   - 避免使用SELECT *，只查询必要字段；\n   - 避免在WHERE子句中使用函数、表达式或不等于操作符（!=、&lt;&gt;）；\n   - 大表分页用LIMIT配合索引（如`WHERE id &gt; 1000 LIMIT 10`）；\n3. 优化表结构：\n   - 选择合适的数据类型（如用INT代替VARCHAR存ID，用DATE代替VARCHAR存日期）；\n   - 拆分大表（水平拆分：按用户ID分表；垂直拆分：将大字段分离到子表）；\n4. 调整数据库参数：\n   - 增大InnoDB缓冲池（innodb_buffer_pool_size），减少磁盘IO；\n   - 合理设置连接数（max_connections），避免连接耗尽；\n5. 使用查询缓存（适用于MySQL 5.7及以下，且数据变更少的场景）；\n6. 读写分离：主库写，从库读，分散单库压力；\n7. 定期分析慢查询日志：通过slow_query_log定位低效SQL，用EXPLAIN分析执行计划。', '查询性能优化是系统性工作，需结合索引、SQL、表结构、参数配置多维度优化。核心原则是“减少数据扫描量”和“利用索引加速查询”，同时避免过度优化（如过早引入分库分表）。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[217]', 18);
INSERT INTO `questions` VALUES (787, '简述MySQL中的锁机制，包括表锁和行锁的区别及应用场景。', 'SHORT_ANSWER', 'HARD', NULL, 'MySQL的锁机制按粒度分为表锁和行锁，区别及应用场景如下：\n一、表锁：\n1. 特点：锁定整个表，粒度大，实现简单，开销小，并发性能低；\n2. 类型：\n   - 读锁（共享锁）：多个事务可同时读，禁止写；\n   - 写锁（排他锁）：仅持有锁的事务可写，禁止其他事务读和写；\n3. 应用场景：MyISAM存储引擎默认使用表锁；适合读多写少、表数据量小的场景（如配置表）。\n二、行锁：\n1. 特点：锁定单行数据，粒度小，实现复杂，开销大，并发性能高；\n2. 类型（InnoDB支持）：\n   - 共享锁（S锁）：事务读数据时获取，允许多个S锁共存；\n   - 排他锁（X锁）：事务写数据时获取，禁止其他锁共存；\n3. 实现：基于索引，无索引时升级为表锁；\n4. 应用场景：InnoDB存储引擎默认使用行锁；适合写操作频繁、并发高的场景（如订单表、用户表）。\n三、其他锁：\n- 意向锁（表级）：表示事务准备加行锁（如IS锁、IX锁），避免表锁和行锁冲突；\n- 元数据锁（MDL）：操作表结构时自动加锁，防止并发修改表结构。', '锁机制是MySQL并发控制的核心，选择表锁还是行锁需权衡粒度和性能：表锁适合简单场景和小表，行锁适合高并发写入的大表。实际使用中，InnoDB的行锁需注意索引的合理设计，避免锁升级。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[214]', 18);
INSERT INTO `questions` VALUES (788, '简述MySQL中视图的作用及使用场景。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'MySQL视图是基于SELECT语句的虚拟表，作用及使用场景如下：\n1. 主要作用：\n   - 简化查询：封装复杂查询逻辑（如多表连接、聚合计算），用户直接查询视图即可；\n   - 数据安全：隐藏敏感字段（如只显示用户ID，不显示手机号），限制数据访问范围；\n   - 逻辑独立：视图屏蔽表结构变化，当表结构修改时，只需调整视图定义，不影响应用；\n   - 重用性：多次使用的复杂查询可定义为视图，避免重复编写SQL。\n2. 使用场景：\n   - 报表生成：将统计分析逻辑（如销售额按月汇总）定义为视图，简化报表查询；\n   - 权限控制：给不同用户授予不同视图的访问权，而非直接访问基表；\n   - 多表联合查询：将常用的多表连接查询定义为视图，减少代码冗余。\n3. 注意事项：\n   - 视图不存储数据，查询视图本质是执行底层SELECT语句，复杂视图可能影响性能；\n   - 并非所有视图都可更新（如含DISTINCT、聚合函数的视图不可写）。', '视图的核心价值是“逻辑封装”和“安全控制”，尤其适合复杂查询场景和多团队协作时的数据访问管理。但需避免过度使用复杂视图，以免影响查询性能。', 0, 6, '2025-11-04 14:24:11', '2025-11-04 14:24:11', '[216]', 18);
INSERT INTO `questions` VALUES (789, '简述MySQL的慢查询日志如何配置及分析。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'MySQL慢查询日志用于记录执行时间超过阈值的SQL，配置及分析步骤如下：\n一、配置慢查询日志：\n1. 查看当前配置：`SHOW VARIABLES LIKE \'%slow_query_log%\';`（是否开启）、`SHOW VARIABLES LIKE \'long_query_time\';`（阈值，默认10秒）；\n2. 临时开启（重启失效）：\n   - `SET GLOBAL slow_query_log = ON;`\n   - `SET GLOBAL long_query_time = 1;`（设置阈值为1秒）\n   - `SET GLOBAL slow_query_log_file = \'/var/log/mysql/slow.log\';`（指定日志路径）\n3. 永久配置（修改my.cnf或my.ini）：\n   ```\n   slow_query_log = ON\n   slow_query_log_file = /var/log/mysql/slow.log\n   long_query_time = 1\n   log_queries_not_using_indexes = ON  # 记录未使用索引的查询\n   ```\n   重启MySQL生效。\n二、分析慢查询日志：\n1. 直接查看日志文件：包含SQL语句、执行时间、锁定时间等信息；\n2. 使用mysqldumpslow工具（MySQL自带）：\n   - 统计最耗时的10条SQL：`mysqldumpslow -s t -t 10 /var/log/mysql/slow.log`\n   - 统计最频繁的10条SQL：`mysqldumpslow -s c -t 10 /var/log/mysql/slow.log`\n3. 第三方工具：如pt-query-digest（Percona Toolkit），生成更详细的分析报告。\n三、优化：根据分析结果，对慢查询SQL进行优化（如加索引、改写SQL）。', '慢查询日志是定位性能瓶颈的关键工具，配置时需合理设置阈值（如1秒），避免日志过大；分析后需结合EXPLAIN执行计划，针对性优化SQL和索引。', 0, 6, '2025-11-04 14:24:12', '2025-11-04 14:24:12', '[217]', 18);
INSERT INTO `questions` VALUES (790, '简述MySQL中事务隔离级别及各级别可能出现的问题。', 'SHORT_ANSWER', 'MEDIUM', NULL, 'MySQL定义了四种事务隔离级别，从低到高依次为：\n1. 读未提交（READ UNCOMMITTED）：\n   - 特点：事务可读取其他未提交事务的数据；\n   - 问题：存在脏读（读未提交数据）、不可重复读、幻读；\n   - 性能：最高（无隔离开销），但安全性最低。\n2. 读已提交（READ COMMITTED）：\n   - 特点：事务只能读取其他已提交事务的数据；\n   - 问题：解决脏读，仍存在不可重复读（同一事务内多次查询结果不一致）、幻读；\n   - 应用：Oracle、SQL Server默认级别。\n3. 可重复读（REPEATABLE READ）：\n   - 特点：同一事务内多次查询结果一致，不受其他事务影响；\n   - 问题：解决脏读、不可重复读，MySQL通过MVCC避免幻读（其他数据库可能仍有幻读）；\n   - 应用：MySQL默认级别。\n4. 串行化（SERIALIZABLE）：\n   - 特点：事务串行执行（加表锁），完全隔离；\n   - 问题：无并发问题，但性能最低；\n   - 应用：安全性要求极高的场景（如金融交易）。\n隔离级别通过`SET TRANSACTION ISOLATION LEVEL 级别名;`设置，级别越高，并发性能越低，需根据业务平衡安全性和性能。', '隔离级别本质是“并发性能”和“数据一致性”的权衡。MySQL的可重复读通过MVCC机制，在保证较高并发的同时避免了幻读，是大多数业务的首选；特殊场景（如支付）可考虑串行化。', 0, 6, '2025-11-04 14:24:12', '2025-11-04 14:24:12', '[208]', 18);
INSERT INTO `questions` VALUES (791, '简述MySQL的分库分表策略及常用工具。', 'SHORT_ANSWER', 'HARD', NULL, '当单库单表数据量过大（如超过1000万行）时，需分库分表提升性能，策略及工具如下：\n一、分库分表策略：\n1. 水平拆分（按数据行拆分）：\n   - 范围拆分：按时间（如按月份分表）、ID范围（如ID 1-100万为表1）；\n   - 哈希拆分：按ID哈希取模（如ID % 10分10表），数据分布均匀；\n   - 优点：解决单表数据量大的问题，扩展性好；\n   - 缺点：跨表查询复杂（如聚合、排序）。\n2. 垂直拆分（按数据表拆分）：\n   - 按字段拆分：将大表的不常用字段或大字段（如TEXT）拆分到子表（如用户表拆分为用户基本表和用户详情表）；\n   - 按业务拆分：将不同业务表分到不同库（如订单库、用户库）；\n   - 优点：降低单表复杂度，便于维护；\n   - 缺点：需多表连接查询。\n二、常用工具：\n1. 中间件：\n   - Sharding-JDBC：客户端分片工具，嵌入应用，无额外部署；\n   - MyCat：服务器端中间件，支持分库分表、读写分离；\n2. 数据库原生：\n   - MySQL Partitioning：表分区功能（逻辑拆分，仍单表）；\n3. 云服务：阿里云DRDS、腾讯云DCDB等，提供托管分库分表服务。\n三、注意事项：\n- 拆分前需规划路由规则（如按ID哈希），避免后期调整困难；\n- 优先考虑水平拆分，垂直拆分适合表结构复杂的场景；\n- 拆分后需处理分布式事务、跨表查询等问题。', '分库分表是解决大数据量问题的终极方案，但会增加系统复杂度，需在数据量达到瓶颈时再实施。实际应用中，可先通过索引优化、读写分离等手段缓解压力，再考虑分库分表。', 0, 6, '2025-11-04 14:24:12', '2025-11-04 14:24:12', '[230]', 18);

SET FOREIGN_KEY_CHECKS = 1;
